<!DOCTYPE html>
<html>
<head>
  <title>BYTE WELLNESS PVT</title>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: 'Montserrat', sans-serif; margin:0; padding:0; background:#f5f7fa; color:#333; }
    header { background:#1C39BB; color:white; text-align:center; padding:30px; font-size:36px; font-weight:800; text-transform:uppercase; }
    .container { max-width:1000px; margin:20px auto; padding:0 20px; }
    .card-grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(220px,1fr)); gap:25px; margin-top:25px; }
    .card { background:white; padding:35px 25px; border-radius:15px; box-shadow:0 6px 20px rgba(0,0,0,0.1); text-align:center; font-weight:600; font-size:22px; cursor:pointer; transition:0.2s; text-transform:uppercase; }
    .card:hover { transform:translateY(-6px); box-shadow:0 10px 25px rgba(0,0,0,0.15); }
    .btn { display:inline-block; margin-top:30px; padding:14px 28px; background:#1C39BB; color:white; font-size:16px; font-weight:700; border:none; border-radius:10px; cursor:pointer; transition:0.3s; text-transform:uppercase; }
    .btn:hover { background:#162f94; }
    h2 { font-weight:700; text-align:center; margin-top:20px; color:#1C39BB; text-transform:uppercase; }
    table { width:100%; border-collapse:collapse; background:white; border-radius:12px; overflow:hidden; box-shadow:0 5px 20px rgba(0,0,0,0.1); text-align:center; font-weight:500; font-size:16px; margin-top:25px; }
    th { background:#1C39BB; color:white; padding:14px; text-transform:uppercase; letter-spacing:1px; }
    td { padding:14px; border-bottom:1px solid #ddd; text-align:center; }
    tr:hover { background:#f1f1f1; }
    .hidden { display:none; }
    #lastSynced { text-align:center; font-weight:700; margin-bottom:10px; text-transform:uppercase; }
    .filters { text-align:center; margin-top:20px; }
    .filters input { margin:0 10px; padding:8px; font-size:14px; }
    .export-btn { margin-top:15px; padding:10px 20px; background:#1C39BB; color:#fff; border:none; border-radius:8px; cursor:pointer; font-weight:600; }
    .export-btn:hover { background:#162f94; }
    tfoot td { font-weight:700; background:#f0f0f0; }
    /* Channel colors */
    .amazon { background:#FF9900; color:white; }
    .shopify { background:#96BF48; color:white; }
    .flipkart { background:#2874F0; color:white; }
    .blinkit { background:#F7E415; color:#333; }
  </style>
</head>
<body>
<header>BYTE WELLNESS PVT</header>

<!-- HOME -->
<div class="container" id="home">
  <div class="card-grid">
    <div class="card" onclick="showSection('inventory')">Inventory</div>
    <div class="card" onclick="showSection('sales')">Sales</div>
  </div>
</div>

<!-- INVENTORY PAGE -->
<div class="container hidden" id="inventory">
  <h2>Warehouses</h2>
  <div class="card-grid">
    <div class="card" onclick="showWarehouse('Master')">Master Warehouse</div>
    <div class="card" onclick="showWarehouse('Mumbai')">Shiprocket - Mumbai</div>
    <div class="card" onclick="showWarehouse('Bangalore')">Shiprocket - Bangalore</div>
    <div class="card" onclick="showWarehouse('Amazon')">Amazon Warehouse</div>
  </div>
  <button class="btn" onclick="showSection('home')">Back</button>
</div>

<!-- WAREHOUSE DETAIL PAGE -->
<div class="container hidden" id="warehouse">
  <h2 id="warehouseName"></h2>
  <div id="lastSynced"></div>
  <table>
    <thead></thead>
    <tbody></tbody>
  </table>
  <button class="btn" onclick="showSection('inventory')">Back to Warehouses</button>
</div>

<!-- SALES MAIN PAGE -->
<div class="container hidden" id="sales">
  <h2>Sales</h2>
  <div class="card-grid">
    <div class="card" onclick="showSection('salesOverview')">Sales Overview</div>
    <div class="card" onclick="showSection('salesShare')">Total Sales & Share</div>
  </div>
  <button class="btn" onclick="showSection('home')">Back</button>
</div>

<!-- SALES OVERVIEW -->
<div class="container hidden" id="salesOverview">
  <h2>Sales Overview</h2>
  <div class="card-grid">
   <div class="card amazon" onclick="showSection('amazonSales')">Amazon</div>
    <div class="card shopify" onclick="alert('Shopify sales page coming soon')">Shopify</div>
    <div class="card flipkart" onclick="showSection('flipkartSales')">Flipkart</div>
    <div class="card blinkit" onclick="showSection('blinkit')">Blinkit</div>
  </div>
  <button class="btn" onclick="showSection('sales')">Back</button>
</div>

<!-- SALES SHARE -->
<div class="container hidden" id="salesShare">
  <h2>Total Sales & Share</h2>
  <p style="text-align:center; font-weight:600; margin-top:20px;">(Summary dashboard will be added here)</p>
  <button class="btn" onclick="showSection('sales')">Back</button>
</div>

<!-- BLINKIT SALES -->
<div class="container hidden" id="blinkit">
  <h2>Blinkit Sales</h2>
  <div class="filters">
    From: <input type="date" id="startDate">
    To: <input type="date" id="endDate">
    <button class="btn" onclick="loadBlinkitData()">Apply</button>
  </div>
  <button class="export-btn" onclick="exportBlinkit()">Export CSV</button>
  <table id="blinkitTable">
    <thead></thead>
    <tbody></tbody>
    <tfoot></tfoot>
  </table>
  <button class="btn" onclick="showSection('salesOverview')">Back to Overview</button>
</div>
  <!-- AMAZON: Sales Overview Tab Content -->
<div id="amazonSales" class="container hidden">
  <h2 style="font-weight:700; text-align:center; margin-top:20px; color:#1C39BB; text-transform:uppercase;">
    Amazon Sales
  </h2>

  <!-- Date Range Filter -->
  <!-- Date Range Filter -->
<div class="filters">
  From: <input type="date" id="amzStart">
  To: <input type="date" id="amzEnd">
  <button id="amzApply" class="btn">Apply</button>
  <button id="amzExport" class="btn" style="background:#0f915a;">Export CSV</button>
</div>

  <!-- STEP Premium Target badge -->
<div id="amzStepWrap" style="display:flex; align-items:center; justify-content:center; margin:6px 0 14px;">
  <span id="amzStepBadge" style="padding:8px 12px; border-radius:999px; font-weight:700; text-transform:uppercase;"></span>
</div>

  <!-- Table -->
  <table id="amazonTable">
    <thead></thead>
    <tbody></tbody>
    <tfoot></tfoot>
  </table>
  <button class="btn" onclick="showSection('salesOverview')">Back to Overview</button>
</div>
  <!-- FLIPKART SALES OVERVIEW -->
<div id="flipkartSales" class="container hidden">
  <h2 style="font-weight:700; text-align:center; margin-top:20px; color:#1C39BB; text-transform:uppercase;">
    Flipkart Sales
  </h2>

  <!-- Date Filter + Buttons -->
  <div class="filters">
    From: <input type="date" id="fkStart">
    To: <input type="date" id="fkEnd">
    <button id="fkApply" class="btn">Apply</button>
    <button id="fkExport" class="btn" style="background:#0f915a;">Export CSV</button>
  </div>

  <!-- Table -->
  <table id="flipkartTable">
    <thead></thead>
    <tbody></tbody>
    <tfoot></tfoot>
  </table>

  <button class="btn" onclick="showSection('salesOverview')">Back to Overview</button>
</div>

<script>
/* ====== CONFIG ====== */
const API_KEY = "AIzaSyD6yREIVE1b8hq0kiYqFoJBfsLzPiGGv4k";
const WAREHOUSE_SHEET_ID = "12Hx1lGMB8dPHND7u3vqbN2itq3QHzBCIiBMkRRWbk6Y";
const BLINKIT_SHEET_ID   = "1LJ7H8Zwy8-mM_1K0TCdke-89qfK00yQAV04OtitC45Q";
const BLINKIT_SHEET = "sheet1"; // exact tab name inside Blinkit sheet

/* ====== INVENTORY ====== */
const warehouseSheets = {
  "Master": "Master",
  "Mumbai": "Mumbai",
  "Bangalore": "Bangalore",
  "Amazon": "Amazon"
};

async function fetchWarehouseData(sheetName) {
  const url = `https://sheets.googleapis.com/v4/spreadsheets/${WAREHOUSE_SHEET_ID}/values/${encodeURIComponent(sheetName)}?key=${API_KEY}`;
  const response = await fetch(url);
  const json = await response.json();
  const values = json.values || [];
  if (values.length === 0) return { headers: [], data: [] };
  
  const headers = values[0];
  const data = values.slice(1);
  return { headers, data };
}

async function showWarehouse(name) {
  showSection('warehouse');
  const sheetName = warehouseSheets[name];
  const { headers, data } = await fetchWarehouseData(sheetName);
  const normHeaders = headers.map(h => (h || "").trim().toLowerCase());

  // Update warehouse title
  document.getElementById("warehouseName").innerText = name + " Warehouse";
  const syncedElem = document.getElementById("lastSynced");

  // Detect "Synced At" column
  const syncedIndex = normHeaders.indexOf("synced at");
  let syncedDate = "";
  if (syncedIndex !== -1 && data.length > 0) {
    const firstValue = (data[0][syncedIndex] || "").trim();
    if (firstValue.includes("/")) {
      const [dd, mm, yyyy] = firstValue.split("/");
      if (dd && mm && yyyy) syncedDate = `${dd}-${mm}-${yyyy}`;
    } else if (firstValue.includes("-")) {
      const parts = firstValue.split("-");
      if (parts[0].length === 4) {
        const [yyyy, mm, dd] = firstValue.substring(0, 10).split("-");
        syncedDate = `${dd}-${mm}-${yyyy}`;
      } else {
        syncedDate = firstValue.substring(0, 10);
      }
    }
  }
  syncedElem.innerText = "LAST SYNCED: " + (syncedDate || "N/A");

  // Build table
  const table = document.querySelector("#warehouse table");
  const thead = table.querySelector("thead");
  const tbody = table.querySelector("tbody");

  // Handle empty sheet
  if (data.length === 0) {
    thead.innerHTML = "";
    tbody.innerHTML = `<tr><td colspan="${headers.length || 1}">No data available</td></tr>`;
    return; // ✅ safe — inside function
  }

  // Prepare headers
  const displayHeaders = headers.filter((_, i) => i !== syncedIndex);
  thead.innerHTML = "<tr>" + displayHeaders.map(h => `<th>${h}</th>`).join("") + "</tr>";

  // Fill table rows
  tbody.innerHTML = "";
  data.forEach(row => {
    const displayRow = row.filter((_, i) => i !== syncedIndex);
    let rowHTML = "<tr>";

    displayRow.forEach((cell, idx) => {
      const header = (displayHeaders[idx] || "").trim().toLowerCase();

      // Highlight Days to Stockout
      if (header === "days to stockout" && cell) {
        const days = parseFloat(cell);
        const threshold = (name === "Amazon") ? 20 : 10;
        const color = days < threshold ? "#FF4D4F" : "#333";
        rowHTML += `<td style="color:${color}; font-weight:600;">${cell}</td>`;
      } else {
        rowHTML += `<td>${cell || ""}</td>`;
      }
    });

    rowHTML += "</tr>";
    tbody.insertAdjacentHTML("beforeend", rowHTML);
  });
} // ✅ clean ending

/* ====== BLINKIT ====== */

// Custom date parser for sheet values
function parseSheetDate(val){
  if(!val) return null;
  const s = String(val).trim();

  // yyyy-mm-dd or yyyy-mm-dd hh:mm:ss
  if(/^\d{4}-\d{2}-\d{2}/.test(s)){
    const [yyyy,mm,dd] = s.substring(0,10).split("-");
    return new Date(Number(yyyy), Number(mm)-1, Number(dd));
  }

  // dd-mm-yyyy
  if(/^\d{2}-\d{2}-\d{4}$/.test(s)){
    const [dd,mm,yyyy] = s.split("-");
    return new Date(Number(yyyy), Number(mm)-1, Number(dd));
  }

  // dd/mm/yyyy
  if(/^\d{2}\/\d{2}\/\d{4}$/.test(s)){
    const [dd,mm,yyyy] = s.split("/");
    return new Date(Number(yyyy), Number(mm)-1, Number(dd));
  }

  // fallback
  const d = new Date(s);
  return isNaN(d.getTime()) ? null : d;
}

// Parse input type=date (always yyyy-mm-dd)
function parseInputDate(val){
  if(!val) return null;
  const [yyyy,mm,dd] = val.split("-");
  return new Date(Number(yyyy), Number(mm)-1, Number(dd));
}

async function fetchBlinkitData(){
  const url = `https://sheets.googleapis.com/v4/spreadsheets/${BLINKIT_SHEET_ID}/values/${encodeURIComponent(BLINKIT_SHEET)}?key=${API_KEY}`;
  const res = await fetch(url);
  const json = await res.json();
  return json.values || [];
}

function groupBlinkitData(values,startDate,endDate){
  if(values.length < 2) return {cities:[], data:{}};
  const headers = values[0];
  const rows = values.slice(1);

  const dateIdx = headers.indexOf("Date");
  const productIdx = headers.indexOf("Product");
  const qtyIdx = headers.indexOf("Qty");
  const salesIdx = headers.indexOf("Sales");
  const cityIdx = headers.indexOf("City");

  const grouped = {}; 
  const cities = new Set();

  rows.forEach(r=>{
    const d = parseSheetDate(r[dateIdx]);
    if(!d) return;

    // inclusive filter
    if(startDate && d < startDate) return;
    if(endDate){
      const endDay = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate(), 23,59,59,999);
      if(d > endDay) return;
    }

    const product = r[productIdx] || "";
    const qty = parseFloat(r[qtyIdx]||0);
    const sales = parseFloat(r[salesIdx]||0);
    const city = r[cityIdx] || "Unknown";

    cities.add(city);
    if(!grouped[product]) grouped[product] = {qty:0,sales:0,byCity:{}};
    grouped[product].qty += qty;
    grouped[product].sales += sales;
    grouped[product].byCity[city] = (grouped[product].byCity[city]||0)+qty;
  });

  return {cities:[...cities], data:grouped};
}

async function loadBlinkitData(){
  const start = document.getElementById("startDate").value;
  const end = document.getElementById("endDate").value;
  const startDate = parseInputDate(start);
  const endDate = parseInputDate(end);

  const values = await fetchBlinkitData();
  const {cities,data} = groupBlinkitData(values,startDate,endDate);

  const table = document.getElementById("blinkitTable");
  const thead = table.querySelector("thead");
  const tbody = table.querySelector("tbody");
  const tfoot = table.querySelector("tfoot");

  let headerHTML="<tr><th>Product</th><th>Qty</th><th>Gross Sales</th>";
  cities.forEach(c=> headerHTML+=`<th>${c}</th>`);
  headerHTML+="</tr>";
  thead.innerHTML=headerHTML;

  let bodyHTML=""; let totalQty=0,totalSales=0; const cityTotals={};
  for(const [product,obj] of Object.entries(data)){
    totalQty+=obj.qty; totalSales+=obj.sales;
    let row=`<tr><td>${product}</td><td>${obj.qty}</td><td>${Math.round(obj.sales)}</td>`;
    cities.forEach(c=>{
      const val=obj.byCity[c]||0;
      row+=`<td>${val}</td>`;
      cityTotals[c]=(cityTotals[c]||0)+val;
    });
    row+="</tr>";
    bodyHTML+=row;
  }
  tbody.innerHTML=bodyHTML;

  let footHTML=`<tr><td><b>TOTAL</b></td><td><b>${totalQty}</b></td><td><b>${Math.round(totalSales)}</b></td>`;
  cities.forEach(c=> footHTML+=`<td><b>${cityTotals[c]||0}</b></td>`);
  footHTML+="</tr>";
  tfoot.innerHTML=footHTML;
}

function exportBlinkit(){
  const table=document.getElementById("blinkitTable");
  let csv=""; const rows=table.querySelectorAll("tr");
  rows.forEach(row=>{
    const cols=row.querySelectorAll("th,td");
    const arr=[]; cols.forEach(c=>arr.push(`"${c.innerText}"`));
    csv+=arr.join(",")+"\n";
  });
  const blob=new Blob([csv],{type:"text/csv"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a"); a.href=url; a.download="blinkit_sales.csv"; a.click();
  URL.revokeObjectURL(url);
}

// ====== Default date = Yesterday (auto-load) ======
document.addEventListener("DOMContentLoaded", ()=>{
  const today = new Date();
  const yesterday = new Date(today);
  yesterday.setDate(today.getDate() - 1);

  const yStr = yesterday.toISOString().slice(0,10);
  const sd = document.getElementById("startDate");
  const ed = document.getElementById("endDate");

  if(sd && ed){
    sd.value = yStr;
    ed.value = yStr;
    loadBlinkitData(); // auto-load yesterday's data
  }
});
/* ====== NAVIGATION ====== */
const SECTIONS=["home","inventory","warehouse","sales","salesOverview","salesShare","blinkit","amazonSales","flipkartSales"];
function showSection(id){ SECTIONS.forEach(s=>document.getElementById(s).classList.add("hidden")); document.getElementById(id).classList.remove("hidden"); }
</script>
 
  <script>

    /* ====== AMAZON (Website Aggregation with Orders + sheet1) ====== */

const AMAZON_SHEET_ID = "1e4Vdkw2Ms0dCxskAKbUfLk3ttqeFT_nbQDhsPtKWWhA"; // Sales sheet
const AMAZON_RANGE = "sheet1"; // tab name for sheet1 (sales/refunds)
const AMAZON_ORDERS_TAB = "Orders"; // Orders tab name

// --- date helpers (reuse parseSheetDate and fmtYMD already defined above)
function parseAmazonOrderDate(val){
  // Orders 'purchase-date' is expected in dd-mm-yyyy or yyyy-mm-dd etc.
  return parseSheetDate(val); // parseSheetDate already handles multiple formats
}

// --- fetch Amazon sheet1 (already present fetchAmazonValues) kept
// --- fetch Orders tab
async function fetchAmazonOrdersValues(){
  const range = encodeURIComponent(AMAZON_ORDERS_TAB);
  const url = `https://sheets.googleapis.com/v4/spreadsheets/${AMAZON_SHEET_ID}/values/${range}?key=${API_KEY}`;
  const res = await fetch(url);
  const json = await res.json();
  return json.values || [];
}

// --- Utility parsers
function parseNumberSafe(x){
  if(x === null || x === undefined) return 0;
  const s = String(x).replace(/,/g, "").trim();
  if(s === "") return 0;
  const n = Number(s);
  return isNaN(n) ? 0 : n;
}

// --- Aggregate Orders & Refunds into combined per-SKU map
function aggregateCombined(ordersVals, salesVals, startDate, endDate){
  // ordersVals: [headers, ...rows] from Orders tab
  // salesVals: sheet1 results: [headers, ...rows]
  const skuMap = new Map(); // sku -> { sku, qty, gross, rto, refunds }

  // --- Process Orders tab
  if((ordersVals || []).length >= 1){
    const headers = ordersVals[0].map(h => (h||"").toString().trim().toLowerCase());
    const idxDate = headers.indexOf("purchase-date");
    const idxSku  = headers.indexOf("sku");
    const idxQty  = headers.indexOf("quantity");
    const idxPrice = headers.indexOf("item-price");
    const idxPromoDisc = headers.indexOf("item-promotion-discount");
    const idxPromoId = headers.indexOf("promotion-ids");

    for(let i=1;i<ordersVals.length;i++){
      const row = ordersVals[i];
      const d = idxDate!==-1 ? parseAmazonOrderDate(row[idxDate]) : null;
      if(!d) continue;
      // inclusive filter
      if(startDate && d < startDate) continue;
      if(endDate){
        const endDay = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate(), 23,59,59,999);
        if(d > endDay) continue;
      }

      const sku = (idxSku!==-1 ? (row[idxSku]||"") : "").toString().trim();
      if(!sku) continue;

      const qty = parseNumberSafe(idxQty!==-1 ? row[idxQty] : 0);
      const price = parseNumberSafe(idxPrice!==-1 ? row[idxPrice] : 0);
      const promoDisc = parseNumberSafe(idxPromoDisc!==-1 ? row[idxPromoDisc] : 0);
      const promoId = idxPromoId!==-1 ? (row[idxPromoId]||"").toString() : "";

      if(!skuMap.has(sku)){
        skuMap.set(sku, { sku, qty:0, gross:0, rto:0, refunds:0, promoQty:0, promoDiscSum:0 });
      }
      const rec = skuMap.get(sku);
      rec.qty += qty;
      rec.gross += price;           // per your instruction: Gross = sum of item-price (not multiplied)
      // track promo specific Buy2 (by exact substring)
      if(typeof promoId === "string" && promoId.indexOf("Percentage Off 2025/08/27 7-27-42-779") !== -1){
        rec.promoQty += qty;
        rec.promoDiscSum += promoDisc;
      }
    }
  }

  // --- Process sheet1 for Refunds/RTO (type === 'refund'), Date column used for filtering
  if((salesVals || []).length >= 1){
    const headers = salesVals[0].map(h => (h||"").toString().trim().toLowerCase());
    const idxDate = headers.indexOf("date");
    const idxType = headers.indexOf("type");
    const idxSku  = headers.indexOf("sku");
    const idxQty  = headers.indexOf("qty");
    const idxSales = headers.indexOf("sales(-gst)");

    for(let i=1;i<salesVals.length;i++){
      const row = salesVals[i];
      const d = idxDate!==-1 ? parseSheetDate(row[idxDate]) : null;
      if(!d) continue;
      if(startDate && d < startDate) continue;
      if(endDate){
        const endDay = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate(), 23,59,59,999);
        if(d > endDay) continue;
      }

      const type = idxType!==-1 ? (row[idxType]||"").toString().trim().toLowerCase() : "";
      if(type !== "refund") continue;

      const sku = idxSku!==-1 ? (row[idxSku]||"").toString().trim() : "";
      // If SKU blank, skip
      if(!sku) continue;

      const qty = parseNumberSafe(idxQty!==-1 ? row[idxQty] : 0);
      const salesVal = parseNumberSafe(idxSales!==-1 ? row[idxSales] : 0);

      if(!skuMap.has(sku)){
        skuMap.set(sku, { sku, qty:0, gross:0, rto:0, refunds:0, promoQty:0, promoDiscSum:0 });
      }
      const rec = skuMap.get(sku);
      rec.rto += qty;
      rec.refunds += Math.abs(salesVal);
    }
  }

  // Convert map -> array
  const rows = Array.from(skuMap.values());
  // Sort by gross descending (for example)
  rows.sort((a,b) => b.gross - a.gross);
  return rows;
}

// --- Evaluate STEP with new rules
function evaluateStepTargetNew(totals, startDate, endDate){
  const targetSalesPerDay = 57836;
  const targetQtyPerDay = 109;

  const s = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
  const e = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
  const days = Math.floor((e - s)/(1000*60*60*24)) + 1;

  const salesTarget = targetSalesPerDay * days;
  const qtyTarget = targetQtyPerDay * days;

  const netSales = totals.gross - totals.refunds - totals.discount;
  const netQty = totals.qty - totals.rto;

  const fulfilled = (netSales >= salesTarget) || (netQty >= qtyTarget);

  return { fulfilled, days, netSales, netQty, salesTarget, qtyTarget };
}

// --- Render aggregated table (SKU | Qty | Gross | RTO | Refunds | Days to Stockout)
function renderAmazonCombinedTable(rows, stockMap){
  const tbl = document.getElementById("amazonTable");
  const thead = tbl.querySelector("thead");
  const tbody = tbl.querySelector("tbody");
  const tfoot = tbl.querySelector("tfoot");

  thead.innerHTML = `
    <tr>
      <th>Sku</th>
      <th>Qty</th>
      <th>Gross</th>
      <th>RTO</th>
      <th>Refunds</th>
      <th>Days to Stockout</th>
    </tr>
  `;

  let bodyHTML = "";
  let totalQty = 0, totalGross = 0, totalRto = 0, totalRefunds = 0;

  rows.forEach(r=>{
    const days = stockMap.get(r.sku) || "—";
    const color = (typeof days === "string") ? "#333" : (parseFloat(days) < 20 ? "#FF4D4F" : "#333");
    bodyHTML += `
      <tr>
        <td>${r.sku}</td>
        <td>${r.qty}</td>
        <td>${moneyInt(r.gross)}</td>
        <td>${r.rto || 0}</td>
        <td>${moneyInt(r.refunds)}</td>
        <td style="color:${color}; font-weight:600;">${days}</td>
      </tr>
    `;
    totalQty += r.qty;
    totalGross += r.gross;
    totalRto += r.rto;
    totalRefunds += r.refunds;
  });

  tbody.innerHTML = bodyHTML || `<tr><td colspan="6">No data in this date range.</td></tr>`;

  tfoot.innerHTML = `
    <tr>
      <td><b>TOTAL</b></td>
      <td><b>${totalQty}</b></td>
      <td><b>${moneyInt(totalGross)}</b></td>
      <td><b>${totalRto}</b></td>
      <td><b>${moneyInt(totalRefunds)}</b></td>
      <td></td>
    </tr>
  `;

  return { totals: { qty: totalQty, gross: totalGross, rto: totalRto, refunds: totalRefunds } };
}

// --- Renders STEP badge and promo line
function renderStepAndPromo(totals, startDate, endDate, promoSummary){
  // Promo line element (create if not exists)
  let promoLine = document.getElementById("amzPromoLine");
  if(!promoLine){
    promoLine = document.createElement("div");
    promoLine.id = "amzPromoLine";
    promoLine.style.fontWeight = "700";
    promoLine.style.marginTop = "6px";
    promoLine.style.textAlign = "center";
    const wrap = document.getElementById("amzStepWrap");
    if(wrap) wrap.appendChild(promoLine);
  }

  const evalRes = evaluateStepTargetNew({ qty: totals.qty, gross: totals.gross, rto: totals.rto, refunds: totals.refunds, discount: promoSummary.discount }, startDate, endDate);
  // render badge (reuse existing renderStepBadge idea)
  const badge = document.getElementById("amzStepBadge");
  if(evalRes.fulfilled){
    badge.textContent = evalRes.days === 1 ? "STEP Premium Target – Fulfilled (For applied date)" : "STEP Premium Target – Fulfilled (For applied date range)";
    badge.style.background = "#0f915a";
  } else {
    badge.textContent = evalRes.days === 1 ? "STEP Premium Target – Unfulfilled (For applied date)" : "STEP Premium Target – Unfulfilled (For applied date range)";
    badge.style.background = "#ff4d4f";
  }
  badge.style.color = "white";

  // Promo line text
  const discountDisplay = moneyInt(promoSummary.discount || 0);
  promoLine.innerText = `Buy 2 Get 15% OFF — Rs.${discountDisplay} (${promoSummary.qty || 0} units)`;

  return evalRes;
}

// --- Export function (existing exportAmazonCSV works on #amazonTable so no change needed)

// --- Main loader (replaces old loadAmazonSales)
async function loadAmazonSales(){
  try{
    const startVal = document.getElementById("amzStart").value;
    const endVal   = document.getElementById("amzEnd").value;
    const startDate = new Date(new Date(startVal).setHours(0,0,0,0));
    const endDate   = new Date(new Date(endVal).setHours(23,59,59,999));
    if(!startVal || !endVal){ alert("Please select a date range."); return; }

    // Fetch Orders (Orders tab), sheet1 and stock map in parallel
    const [ordersVals, amazonValues, stockMap] = await Promise.all([
      fetchAmazonOrdersValues(),
      fetchAmazonValues(),
      fetchAmazonStockData()
    ]);

    // Aggregate combined per SKU using Orders for Qty/Gross and sheet1 for refunds/rto
    const rows = aggregateCombined(ordersVals, amazonValues, startDate, endDate);

    // Compute promo summary (Buy2) by summing promoQty and promoDiscSum across rows
    let promoSummary = { qty: 0, discount: 0 };
    rows.forEach(r=>{
      promoSummary.qty += (r.promoQty || 0);
      promoSummary.discount += (r.promoDiscSum || 0);
    });

    // Render table and totals
    const out = renderAmazonCombinedTable(rows, stockMap);

    // Compute and show STEP badge + promo line
    const evalRes = renderStepAndPromo(out.totals, startDate, endDate, promoSummary);

  }catch(err){
    console.error(err);
    alert("Could not load Amazon data. Check console for details.");
  }
}

// --- initialize UI (wire up apply + export buttons)
(function initAmazonUI(){
  const applyBtn = document.getElementById("amzApply");
  const exportBtn = document.getElementById("amzExport");
  if(!applyBtn) return;

  setAmazonDefaultDates();
  applyBtn.addEventListener("click", loadAmazonSales);
  exportBtn.addEventListener("click", exportAmazonCSV);

  function setAmazonDefaultDates(){
  const end = new Date(); 
  end.setDate(end.getDate() - 1);
  const start = new Date(end);
  document.getElementById("amzStart").value = fmtYMD(start);
  document.getElementById("amzEnd").value   = fmtYMD(end);
}

  
  loadAmazonSales();
})();


/* ====== FLIPKART SALES OVERVIEW (Google Sheets Integration) ====== */

const FLIPKART_SHEET_ID = "1e98eoyoGOeEiQ3hFAKBON-VH85byuXV042vzqC8Yhkw";
const FK_SALES_TAB = "SALES";
const FK_RTO_TAB = "RTO";
const FK_WAREHOUSE_TAB = "Bangalore"; // from Warehouse sheet (Days to Stockout)

/* ---- Helpers ---- */
function parseFlipkartDate(val) {
  if (!val) return null;
  const s = String(val).trim();
  if (/^\d{2}\/\d{2}\/\d{4}$/.test(s)) {
    const [dd, mm, yyyy] = s.split("/");
    return new Date(+yyyy, +mm - 1, +dd);
  }
  if (/^\d{4}-\d{2}-\d{2}/.test(s)) {
    const [y, m, d] = s.substring(0, 10).split("-");
    return new Date(+y, +m - 1, +d);
  }
  const d = new Date(s);
  return isNaN(d.getTime()) ? null : d;
}

function toNum(n) {
  const x = parseFloat(String(n || "").replace(/,/g, ""));
  return isNaN(x) ? 0 : x;
}

/* ---- Fetch any tab (use explicit range to avoid 400) ---- */
async function fetchFlipkartTab(tabName) {
  const range = `${encodeURIComponent(tabName)}!A1:Z`;
  const url = `https://sheets.googleapis.com/v4/spreadsheets/${FLIPKART_SHEET_ID}/values/${range}?key=${API_KEY}`;
  const res = await fetch(url);
  const json = await res.json();
  return json.values || [];
}

/* ---- Fetch warehouse data ---- */
async function fetchBangaloreStock() {
  const range = `${encodeURIComponent(FK_WAREHOUSE_TAB)}!A1:Z`;
  const url = `https://sheets.googleapis.com/v4/spreadsheets/${WAREHOUSE_SHEET_ID}/values/${range}?key=${API_KEY}`;
  const res = await fetch(url);
  const json = await res.json();
  const values = json.values || [];
  const map = new Map();
  if (values.length > 1) {
    const headers = values[0].map(h => (h || "").trim().toLowerCase());
    const skuIdx = headers.indexOf("sku");
    const daysIdx = headers.indexOf("days to stockout");
    if (skuIdx === -1 || daysIdx === -1) {
      // header mismatch: return empty map
      return map;
    }
    for (let i = 1; i < values.length; i++) {
      const row = values[i];
      const sku = (row[skuIdx] || "").trim();
      const days = (row[daysIdx] || "").trim();
      if (sku) map.set(sku, days);
    }
  }
  return map;
}

/* ---- Combine Sales + RTO + Warehouse ---- */
function combineFlipkartData(salesVals, rtoVals, stockMap, startDate, endDate) {
  if ((salesVals || []).length < 2 && (rtoVals || []).length < 2) return [];

  // Identify headers (safely)
  const sHead = (salesVals[0] || []).map(h => (h || "").toString().trim().toLowerCase());
  const rHead = (rtoVals[0] || []).map(h => (h || "").toString().trim().toLowerCase());

  const sDateIdx = sHead.indexOf("ordered on");
  const sSkuIdx = sHead.indexOf("sku");
  const sQtyIdx = sHead.indexOf("quantity");
  const sAmtIdx = sHead.indexOf("invoice amount");

  const rDateIdx = rHead.indexOf("order cancellation date");
  const rSkuIdx = rHead.indexOf("sku");
  const rQtyIdx = rHead.indexOf("quantity");
  const rAmtIdx = rHead.indexOf("total");

  const byKey = new Map();

  // inclusive end-of-day for filtering
  const endInclusive = endDate ? new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate(), 23, 59, 59, 999) : null;

  // --- SALES aggregation ---
if (salesVals && salesVals.length > 1 && sDateIdx !== -1 && sSkuIdx !== -1) {
  for (let i = 1; i < salesVals.length; i++) {
    const row = salesVals[i];
    const d = parseFlipkartDate(row[sDateIdx]);
    if (!d) continue;
    if (startDate && d < startDate) continue;
    if (endInclusive && d > endInclusive) continue;

    const sku = (row[sSkuIdx] || "").trim();
    if (!sku) continue;

    // group by SKU only (combine across dates)
    const key = sku;
    if (!byKey.has(key)) byKey.set(key, { sku, qty: 0, gross: 0, rto: 0, refund: 0 });
    const rec = byKey.get(key);
    rec.qty += toNum(row[sQtyIdx]);
    rec.gross += toNum(row[sAmtIdx]);
  }
}

// --- RTO aggregation ---
if (rtoVals && rtoVals.length > 1 && rDateIdx !== -1 && rSkuIdx !== -1) {
  for (let i = 1; i < rtoVals.length; i++) {
    const row = rtoVals[i];
    const d = parseFlipkartDate(row[rDateIdx]);
    if (!d) continue;
    if (startDate && d < startDate) continue;
    if (endInclusive && d > endInclusive) continue;

    const sku = (row[rSkuIdx] || "").trim();
    if (!sku) continue;

    // group by SKU only (combine across dates)
    const key = sku;
    if (!byKey.has(key)) byKey.set(key, { sku, qty: 0, gross: 0, rto: 0, refund: 0 });
    const rec = byKey.get(key);
    rec.rto += toNum(row[rQtyIdx]);
    rec.refund += toNum(row[rAmtIdx]);
  }
}

  // --- Merge Days to Stockout ---
  const rows = [];
  byKey.forEach(rec => {
    rec.days = stockMap.get(rec.sku) || "—";
    rows.push(rec);
  });

  // --- Sort by highest Qty descending
  rows.sort((a, b) => b.qty - a.qty);

  return rows;
}

/* ---- Render Table ---- */
function renderFlipkartTable(rows) {
  const tbl = document.getElementById("flipkartTable");
  const thead = tbl.querySelector("thead");
  const tbody = tbl.querySelector("tbody");
  const tfoot = tbl.querySelector("tfoot");

  thead.innerHTML = `
    <tr>
      <th>SKU</th>
      <th>Qty</th>
      <th>Gross</th>
      <th>RTO</th>
      <th>Refunds</th>
      <th>Days to Stockout</th>
    </tr>
  `;

  let totalQty = 0, totalGross = 0, totalRto = 0, totalRefund = 0;
  let bodyHTML = "";

  if (!rows || rows.length === 0) {
    tbody.innerHTML = `<tr><td colspan="6">No data found for this range.</td></tr>`;
    tfoot.innerHTML = `
      <tr>
        <td><b>TOTAL</b></td>
        <td><b>0</b></td>
        <td><b>0</b></td>
        <td><b>0</b></td>
        <td><b>0</b></td>
        <td></td>
      </tr>
    `;
    return;
  }

  rows.forEach(r => {
    totalQty += r.qty;
    totalGross += r.gross;
    totalRto += r.rto;
    totalRefund += r.refund;

    const days = parseFloat(r.days);
    const color = !isNaN(days) && days < 10 ? "#FF4D4F" : "#333";

    bodyHTML += `
      <tr>
        <td>${r.sku}</td>
        <td>${r.qty}</td>
        <td>${r.gross.toFixed(0)}</td>
        <td>${r.rto}</td>
        <td>${r.refund.toFixed(0)}</td>
        <td style="color:${color}; font-weight:600;">${r.days}</td>
      </tr>
    `;
  });

  tbody.innerHTML = bodyHTML;
  tfoot.innerHTML = `
    <tr>
      <td><b>TOTAL</b></td>
      <td><b>${totalQty}</b></td>
      <td><b>${totalGross.toFixed(0)}</b></td>
      <td><b>${totalRto}</b></td>
      <td><b>${totalRefund.toFixed(0)}</b></td>
      <td></td>
    </tr>
  `;
}

/* ---- Export CSV ---- */
function exportFlipkartCSV() {
  const table = document.getElementById("flipkartTable");
  let csv = "";
  table.querySelectorAll("tr").forEach(tr => {
    const cols = tr.querySelectorAll("th,td");
    const line = Array.from(cols).map(td => `"${td.innerText.replace(/"/g, '""')}"`).join(",");
    csv += line + "\n";
  });
  const blob = new Blob([csv], { type: "text/csv" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = "flipkart_sales.csv"; a.click();
  URL.revokeObjectURL(url);
}

/* ---- Load Flipkart Sales ---- */
async function loadFlipkartSales() {
  try {
    const startVal = document.getElementById("fkStart").value;
    const endVal = document.getElementById("fkEnd").value;
    if (!startVal || !endVal) return alert("Please select a date range.");
    const startDate = new Date(startVal);
startDate.setHours(0, 0, 0, 0); // start from beginning of the selected day

const endDate = new Date(endVal);
endDate.setHours(23, 59, 59, 999); // include the entire end day


    const [salesVals, rtoVals, stockMap] = await Promise.all([
      fetchFlipkartTab(FK_SALES_TAB),
      fetchFlipkartTab(FK_RTO_TAB),
      fetchBangaloreStock()
    ]);

    const rows = combineFlipkartData(salesVals, rtoVals, stockMap, startDate, endDate);
    renderFlipkartTable(rows);
  } catch (err) {
    console.error("Flipkart load error:", err);
    alert("Error loading Flipkart data. See console for details.");
  }
}

/* ---- Init UI ---- */
(function initFlipkartUI() {
  const applyBtn = document.getElementById("fkApply");
  const exportBtn = document.getElementById("fkExport");
  if (!applyBtn) return;

  // Default date: yesterday
  const today = new Date();
  const y = new Date(today);
  y.setDate(today.getDate() - 1);
  const yStr = y.toISOString().slice(0, 10);
  document.getElementById("fkStart").value = yStr;
  document.getElementById("fkEnd").value = yStr;

    applyBtn.addEventListener("click", loadFlipkartSales);
  exportBtn.addEventListener("click", exportFlipkartCSV);

  // ✅ Auto-load yesterday's data on page load
  loadFlipkartSales();
})();


</script>


</body>
</html>


























