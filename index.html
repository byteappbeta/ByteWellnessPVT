<!DOCTYPE html>
<html>
<head>
  <title>BYTE WELLNESS PVT</title>
  <!-- ‚úÖ PWA: App Installation + Icons -->
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#1C39BB">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<link rel="apple-touch-icon" href="icon-192.png">
<link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <style>
    body { font-family: 'Montserrat', sans-serif; margin:0; padding:0; background:#f5f7fa; color:#333; }
    header { background:#1C39BB; color:white; text-align:center; padding:30px; font-size:36px; font-weight:800; text-transform:uppercase; }
    .container { max-width:1000px; margin:20px auto; padding:0 20px; }
    .card-grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(220px,1fr)); gap:25px; margin-top:25px; }
    .card { background:white; padding:35px 25px; border-radius:15px; box-shadow:0 6px 20px rgba(0,0,0,0.1); text-align:center; font-weight:600; font-size:22px; cursor:pointer; transition:0.2s; text-transform:uppercase; }
    .card:hover { transform:translateY(-6px); box-shadow:0 10px 25px rgba(0,0,0,0.15); }
    .btn { display:inline-block; margin-top:30px; padding:14px 28px; background:#1C39BB; color:white; font-size:16px; font-weight:700; border:none; border-radius:10px; cursor:pointer; transition:0.3s; text-transform:uppercase; }
    .btn:hover { background:#162f94; }
    h2 { font-weight:700; text-align:center; margin-top:20px; color:#1C39BB; text-transform:uppercase; }
    table { width:100%; border-collapse:collapse; background:white; border-radius:12px; overflow:hidden; box-shadow:0 5px 20px rgba(0,0,0,0.1); text-align:center; font-weight:500; font-size:16px; margin-top:25px; }
    th { background:#1C39BB; color:white; padding:14px; text-transform:uppercase; letter-spacing:1px; }
    td { padding:14px; border-bottom:1px solid #ddd; text-align:center; }
    tr:hover { background:#f1f1f1; }
    .hidden { display:none; }
    #lastSynced { text-align:center; font-weight:700; margin-bottom:10px; text-transform:uppercase; }
    .filters { text-align:center; margin-top:20px; }
    .filters input { margin:0 10px; padding:8px; font-size:14px; }
    .export-btn { margin-top:15px; padding:10px 20px; background:#1C39BB; color:#fff; border:none; border-radius:8px; cursor:pointer; font-weight:600; }
    .export-btn:hover { background:#162f94; }
    tfoot td { font-weight:700; background:#f0f0f0; }
    /* Channel colors */
    .amazon { background:#FF9900; color:white; }
    .shopify { background:#96BF48; color:white; }
    .flipkart { background:#2874F0; color:white; }
    .blinkit { background:#F7E415; color:#333; }

/* ===== SMART DESKTOP LAYOUT (UNIFIED VERSION) ===== */
html, body {
  width: 100%;
  height: 100%;
  margin: 0;
  background-color: #f8f9fb;
  overflow-x: hidden;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
}

/* --- Scale down desktop layout dynamically for smaller screens --- */
@media (min-width: 1600px) {
  body { zoom: 1; transform: none; }
}
@media (max-width: 1600px) and (min-width: 1200px) {
  body { zoom: 0.95; transform-origin: top center; }
}
@media (max-width: 1200px) and (min-width: 992px) {
  body { zoom: 0.9; transform-origin: top center; }
}
@media (max-width: 992px) and (min-width: 768px) {
  body { zoom: 0.85; transform-origin: top center; }
}
@media (max-width: 768px) and (min-width: 600px) {
  body { zoom: 0.8; transform-origin: top center; }
}
@media (max-width: 600px) and (min-width: 420px) {
  body { zoom: 0.75; transform-origin: top center; }
}
@media (max-width: 420px) {
  body { zoom: 0.7; transform-origin: top center; }
}

/* --- Always maintain 3-column warehouse layout like desktop --- */
.warehouses {
  display: grid !important;
  grid-template-columns: repeat(3, 1fr) !important;
  gap: 20px !important;
  justify-content: center !important;
  align-items: start !important;
  width: 100% !important;
  max-width: 1200px !important;
  margin: 0 auto !important;
}

/* --- Button consistency --- */
button, .btn {
  font-size: 16px !important;
  padding: 12px 20px !important;
}

/* --- Back button spacing --- */
.btn-back, button[onclick*="showSection"] {
  margin-top: 25px !important;
}

/* --- Ensure stable scrolling --- */
body {
  overflow-y: auto;
  overscroll-behavior: contain;
}

html, body {
  overflow-x: hidden !important;
}

    /* Responsive chart sizing */
#salesShareChart {
  width: 100% !important;
  height: 100% !important;
}

@media (max-width: 768px) {
  #salesShareChart {
    width: 260px !important;
    height: 260px !important;
  }
}

@media (min-width: 769px) and (max-width: 1200px) {
  #salesShareChart {
    width: 320px !important;
    height: 320px !important;
  }
}

@media (min-width: 1201px) {
  #salesShareChart {
    width: 360px !important;
    height: 360px !important;
  }
}


    
  </style>
  <!-- PWA Meta for Splash Screen & Theme -->
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#1C39BB" />
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Byte Wellness">
<link rel="apple-touch-icon" href="icon-512.png">

<!-- iOS Splash Screens (auto adjusts for all devices) -->
<link rel="apple-touch-startup-image" href="icon-512.png">

</head>
<body>
<header>BYTE WELLNESS PVT</header>

<!-- HOME -->
<div class="container" id="home">
  <div class="card-grid">
    <div class="card" onclick="showSection('inventory')">Inventory</div>
    <div class="card" onclick="showSection('sales')">Sales</div>
  </div>
</div>

<!-- INVENTORY PAGE -->
<div class="container hidden" id="inventory">
  <h2>Warehouses</h2>
  <div class="card-grid">
    <div class="card" onclick="showWarehouse('Master')">Master Warehouse</div>
    <div class="card" onclick="showWarehouse('Mumbai')">Shiprocket - Mumbai</div>
    <div class="card" onclick="showWarehouse('Bangalore')">Shiprocket - Bangalore</div>
    <div class="card" onclick="showWarehouse('Amazon')">Amazon Warehouse</div>
    <div class="card" onclick="showWarehouse('Blinkit')">Blinkit Warehouse</div>
    <div class="card" onclick="showAllWarehouses()">All Warehouses</div>
  </div>
  <button class="btn" onclick="showSection('home')">Back</button>
</div>

<!-- WAREHOUSE DETAIL PAGE -->
<div class="container hidden" id="warehouse">
  <h2 id="warehouseName"></h2>
  <div id="lastSynced"></div>
  <table>
    <thead></thead>
    <tbody></tbody>
  </table>
  <button class="btn" onclick="showSection('inventory')">Back to Warehouses</button>
</div>

<!-- SALES MAIN PAGE -->
<div class="container hidden" id="sales">
  <h2>Sales</h2>
  <div class="card-grid">
    <div class="card" onclick="showSection('salesOverview')">Sales Overview</div>
    <div class="card" onclick="showSection('salesShare')">Total Sales & Share</div>
  </div>
  <button class="btn" onclick="showSection('home')">Back</button>
</div>

<!-- SALES OVERVIEW -->
<div class="container hidden" id="salesOverview">
  <h2>Sales Overview</h2>
  <div class="card-grid">
   <div class="card amazon" onclick="showSection('amazonSales')">Amazon</div>
    <div class="card shopify" onclick="showSection('shopifySalesSection')">Shopify</div>
    <div class="card flipkart" onclick="showSection('flipkartSales')">Flipkart</div>
    <div class="card blinkit" onclick="showSection('blinkit')">Blinkit</div>
  </div>
  <button class="btn" onclick="showSection('sales')">Back</button>
</div>

<!-- ü•ß TOTAL SALES & SHARE SECTION -->
<div class="container hidden" id="salesShare">
  <h2>Total Sales & Share</h2>

  <!-- üîπ Date Range Filter -->
  <div class="filters">
    From: <input type="date" id="shareStart">
    To: <input type="date" id="shareEnd">
    <button class="btn" onclick="renderSalesShare()">Apply</button>
  </div>

<!-- üîπ Chart & Legend -->
<div style="display:flex; justify-content:center; align-items:center; flex-wrap:wrap; gap:40px; margin-top:20px;">
  <div style="width:320px; height:320px; display:flex; align-items:center; justify-content:center;">
    <canvas id="salesShareChart"></canvas>
  </div>
  <div id="salesShareLegend" style="font-weight:600; font-size:16px;"></div>
</div>

<p id="salesShareStatus" style="text-align:center; font-weight:600; margin-top:20px;"></p>
<button class="btn" style="margin-top:30px;" onclick="showSection('sales')">Back</button>
</div>

<!-- BLINKIT SALES -->
<div class="container hidden" id="blinkit">
  <h2>Blinkit Sales</h2>
  <div class="filters">
    From: <input type="date" id="startDate">
    To: <input type="date" id="endDate">
    <button class="btn" onclick="loadBlinkitData()">Apply</button>
  </div>
  <button class="export-btn" onclick="exportBlinkit()">Export CSV</button>
  <table id="blinkitTable">
    <thead></thead>
    <tbody></tbody>
    <tfoot></tfoot>
  </table>
  <button class="btn" onclick="showSection('salesOverview')">Back to Overview</button>
</div>
  <!-- AMAZON: Sales Overview Tab Content -->
<div id="amazonSales" class="container hidden">
  <h2 style="font-weight:700; text-align:center; margin-top:20px; color:#1C39BB; text-transform:uppercase;">
    Amazon Sales
  </h2>

  <!-- Date Range Filter -->
  <!-- Date Range Filter -->
<div class="filters">
  From: <input type="date" id="amzStart">
  To: <input type="date" id="amzEnd">
  <button id="amzApply" class="btn">Apply</button>
  <button id="amzExport" class="btn" style="background:#0f915a;">Export CSV</button>
</div>

  <!-- STEP Premium Target badge -->
<div id="amzStepWrap" style="display:flex; flex-direction:column; align-items:center; justify-content:center; margin:10px 0 16px; gap:6px;">
  <span id="amzStepBadge" style="padding:8px 12px; border-radius:999px; font-weight:700; text-transform:uppercase;"></span>
</div>

  <!-- Table -->
  <table id="amazonTable">
    <thead></thead>
    <tbody></tbody>
    <tfoot></tfoot>
  </table>
  <button class="btn" onclick="showSection('salesOverview')">Back to Overview</button>
</div>
  <!-- FLIPKART SALES OVERVIEW -->
<div id="flipkartSales" class="container hidden">
  <h2 style="font-weight:700; text-align:center; margin-top:20px; color:#1C39BB; text-transform:uppercase;">
    Flipkart Sales
  </h2>

  <!-- Date Filter + Buttons -->
  <div class="filters">
    From: <input type="date" id="fkStart">
    To: <input type="date" id="fkEnd">
    <button id="fkApply" class="btn">Apply</button>
    <button id="fkExport" class="btn" style="background:#0f915a;">Export CSV</button>
  </div>

  <!-- Table -->
  <table id="flipkartTable">
    <thead></thead>
    <tbody></tbody>
    <tfoot></tfoot>
  </table>

  <button class="btn" onclick="showSection('salesOverview')">Back to Overview</button>
</div>

  <!-- START: Shopify Sales Section (standalone paste) -->
<!-- ‚úÖ REPLACEMENT: Advanced Shopify Sales Dashboard -->
<div id="shopifySalesSection" class="container hidden">
  <h2 style="font-weight:700; text-align:center; margin-top:20px; color:#1C39BB; text-transform:uppercase;">
    Shopify Sales
  </h2>

<div class="filters filter-bar" id="shopifyFilterBar">
  From: <input type="date" id="shopifyStart"> To: <input type="date" id="shopifyEnd">
  <button id="shopifyApply" class="btn apply-btn">Apply</button>
  <button id="shopifyExport" class="btn export-btn">Export CSV</button>
</div>

  <!-- Dual Tables -->
  <div class="tables-container" style="display:grid;grid-template-columns:1fr 340px;gap:20px;align-items:start;margin-top:20px;">
    <!-- Left Table: SKU Summary -->
    <div style="background:white;border-radius:12px;box-shadow:0 6px 20px rgba(0,0,0,0.08);overflow:hidden;">
      <table id="shopifyTable" style="width:100%;border-collapse:collapse;">
        <thead>
          <tr>
            <th style="padding:14px;">SKU</th>
            <th style="padding:14px;">QTY</th>
            <th style="padding:14px;">GROSS</th>
            <th style="padding:14px;">RTO UNITS</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td colspan="4" style="text-align:center;padding:24px;">Fetching Shopify data...</td>
          </tr>
        </tbody>
        <tfoot style="background:#f6f7f9;font-weight:700;"></tfoot>
      </table>
    </div>

    <!-- Right Table: Summary -->
    <div style="background:white;border-radius:12px;box-shadow:0 6px 20px rgba(0,0,0,0.08);overflow:hidden;">
      <table id="shopifySummary" style="width:100%;border-collapse:collapse;">
        <thead>
          <tr><th colspan="2" style="padding:14px 12px;">Summary</th></tr>
        </thead>
        <tbody style="font-weight:600;">
          <tr><td style="padding:10px 14px;">Total Orders</td><td style="text-align:right;padding:10px 14px;">-</td></tr>
          <tr><td style="padding:10px 14px;">RTO</td><td style="text-align:right;padding:10px 14px;">-</td></tr>
          <tr><td style="padding:10px 14px;">DELIVERED</td><td style="text-align:right;padding:10px 14px;">-</td></tr>
          <tr><td style="padding:10px 14px;">Pack of 2</td><td style="text-align:right;padding:10px 14px;">-</td></tr>
          <tr><td style="padding:10px 14px;">Pack of 3</td><td style="text-align:right;padding:10px 14px;">-</td></tr>
          <tr><td style="padding:10px 14px;">Shipping Charges</td><td style="text-align:right;padding:10px 14px;">-</td></tr>
          <tr><td style="padding:10px 14px;">Discounts</td><td style="text-align:right;padding:10px 14px;">-</td></tr>
          <tr><td style="padding:10px 14px;">Refunds</td><td style="text-align:right;padding:10px 14px;">-</td></tr>
          <tr><td style="padding:10px 14px;">Total Sales <span class="info-icon" title="Gross + Shipping Charges - Discounts">‚ÑπÔ∏è</span></td><td style="text-align:right;padding:10px 14px;">-</td></tr>
          <tr><td style="padding:10px 14px;">Net Sales <span class="info-icon" title="Total Sales - Refunds">‚ÑπÔ∏è</span></td><td style="text-align:right;padding:10px 14px;">-</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <button class="btn" style="margin-top:25px;" onclick="showSection('salesOverview')">Back to Overview</button>
</div>


<script>
/* ====== CONFIG ====== */
const API_KEY = "AIzaSyD6yREIVE1b8hq0kiYqFoJBfsLzPiGGv4k";
const WAREHOUSE_SHEET_ID = "12Hx1lGMB8dPHND7u3vqbN2itq3QHzBCIiBMkRRWbk6Y";
const BLINKIT_SHEET_ID   = "1LJ7H8Zwy8-mM_1K0TCdke-89qfK00yQAV04OtitC45Q";
const BLINKIT_SHEET = "sheet1"; // exact tab name inside Blinkit sheet

  // üßπ Global helper: remove the All Warehouses controls if present
function removeWarehouseControls() {
  const controls = document.getElementById("warehouseControls");
  if (controls) controls.remove();
}

/* ====== INVENTORY ====== */
const warehouseSheets = {
  "Master": "Master",
  "Mumbai": "Mumbai",
  "Bangalore": "Bangalore",
  "Amazon": "Amazon",
  "Blinkit": "Blinkit"
};

async function fetchWarehouseData(sheetName) {
  const url = `https://sheets.googleapis.com/v4/spreadsheets/${WAREHOUSE_SHEET_ID}/values/${encodeURIComponent(sheetName)}?key=${API_KEY}`;
  const response = await fetch(url);
  const json = await response.json();
  const values = json.values || [];
  if (values.length === 0) return { headers: [], data: [] };
  
  const headers = values[0];
  const data = values.slice(1);
  return { headers, data };
}

async function showWarehouse(name) {
  removeWarehouseControls();
  showSection('warehouse');

  const sheetName = warehouseSheets[name];
  const { headers, data } = await fetchWarehouseData(sheetName);

  // normalize headers (trim + lowercase)
  const normHeaders = headers.map(h => (h || "").toString().trim().toLowerCase());

  // Update title
  document.getElementById("warehouseName").innerText = name + " Warehouse";
  const syncedElem = document.getElementById("lastSynced");

  // Find synced column index: allow both "synced at" and "last updated"
  let syncedIndex = normHeaders.indexOf("synced at");
  if (syncedIndex === -1) syncedIndex = normHeaders.indexOf("last updated");

  // Extract first non-empty sync value (if exists)
  let syncedDate = "";
  if (syncedIndex !== -1 && data.length > 0) {
    for (let r = 0; r < data.length; r++) {
      const rawVal = (data[r][syncedIndex] || "").toString().trim();
      if (!rawVal) continue;
      // parse common formats:
      if (rawVal.includes("/")) {
        // dd/mm/yyyy
        const parts = rawVal.split("/");
        if (parts.length >= 3) {
          const dd = parts[0].padStart(2, "0");
          const mm = parts[1].padStart(2, "0");
          const yyyy = parts[2].length === 2 ? ("20" + parts[2]) : parts[2];
          syncedDate = `${dd}-${mm}-${yyyy}`;
          break;
        }
      } else if (rawVal.includes("-")) {
        // could be yyyy-mm-dd or dd-mm-yyyy or yyyy-mm-dd hh:mm:ss
        const first10 = rawVal.substring(0, 10);
        const parts = first10.split("-");
        if (parts.length === 3) {
          if (parts[0].length === 4) {
            // yyyy-mm-dd
            const yyyy = parts[0], mm = parts[1], dd = parts[2];
            syncedDate = `${dd}-${mm}-${yyyy}`;
            break;
          } else {
            // dd-mm-yyyy
            const dd = parts[0], mm = parts[1], yyyy = parts[2];
            syncedDate = `${dd}-${mm}-${yyyy}`;
            break;
          }
        }
      } else {
        // fallback: try Date parse
        const d = new Date(rawVal);
        if (!isNaN(d.getTime())) {
          const dd = String(d.getDate()).padStart(2, "0");
          const mm = String(d.getMonth() + 1).padStart(2, "0");
          const yyyy = d.getFullYear();
          syncedDate = `${dd}-${mm}-${yyyy}`;
          break;
        }
      }
    }
  }

  // Show last synced line (match other warehouse pages styling: uppercase + bold)
  syncedElem.innerText = "LAST SYNCED: " + (syncedDate || "N/A");

  const table = document.querySelector("#warehouse table");
  const thead = table.querySelector("thead");
  const tbody = table.querySelector("tbody");

  // If no data
  if (!data || data.length === 0) {
    thead.innerHTML = "";
    tbody.innerHTML = `<tr><td colspan="${Math.max(headers.length,1)}">No data available</td></tr>`;
    return;
  }

  // Build display headers: remove synced column
  const displayHeaders = headers.filter((_, i) => i !== syncedIndex)
    .map(h => {
      if (!h) return "";
      const hnorm = h.toString().trim();
      // rename for display:
      if (hnorm.toLowerCase() === "warehouse") return "ITEM - WAREHOUSE";
      if (hnorm.toLowerCase() === "scheduled inventory") return "SCHEDULED";
      return hnorm;
    });

  thead.innerHTML = "<tr>" + displayHeaders.map(h => `<th>${h}</th>`).join("") + "</tr>";

  // Render rows: exclude synced col
  tbody.innerHTML = "";
  data.forEach(row => {
    const displayRow = row.filter((_, i) => i !== syncedIndex);
    let rowHTML = "<tr>";

    displayRow.forEach((cell, idx) => {
      const headerLower = (displayHeaders[idx] || "").toString().trim().toLowerCase();

      // Keep days-to-stockout coloring logic (unchanged)
      if (headerLower === "days to stockout" && cell) {
        const days = parseFloat(String(cell).replace(/,/g, ""));
        const threshold = (name === "Amazon") ? 20 : 10;
        const color = (!isNaN(days) && days < threshold) ? "#FF4D4F" : "#333";
        rowHTML += `<td style="color:${color}; font-weight:600;">${cell}</td>`;
      } else {
        // Normal cell
        rowHTML += `<td>${cell || ""}</td>`;
      }
    });

    rowHTML += "</tr>";
    tbody.insertAdjacentHTML("beforeend", rowHTML);
  });
}


/* ====== ALL-IN-ONE WAREHOUSE (SUMMARY VIEW + EXPORT + SKU OVERRIDES) ====== */
async function showAllWarehouses() {
  removeWarehouseControls(); // cleanup from other pages
  showSection("warehouse");

  const titleEl = document.getElementById("warehouseName");
  const syncedEl = document.getElementById("lastSynced");
  titleEl.innerText = "All Warehouses";

  const table = document.querySelector("#warehouse table");
  const thead = table.querySelector("thead");
  const tbody = table.querySelector("tbody");

  // üß© Export button + format note (only show on All Warehouses)
  let oldWrapper = document.getElementById("warehouseControls");
  if (oldWrapper) oldWrapper.remove(); // always reset before adding a new one

  const wrapper = document.createElement("div");
  wrapper.id = "warehouseControls";
  wrapper.style.display = "flex";
  wrapper.style.alignItems = "center";
  wrapper.style.justifyContent = "center";
  wrapper.style.gap = "10px";
  wrapper.style.marginBottom = "10px";

  const btn = document.createElement("button");
  btn.innerText = "Export CSV";
  btn.id = "exportAllBtn";
  btn.className = "export-btn";
  btn.onclick = exportAllWarehouses;

  const note = document.createElement("span");
  note.innerText = "Format: Inventory [Last 30 Days Sale] (Days to Stockout)";
  note.style.fontSize = "12px";
  note.style.color = "#555";
  note.style.fontStyle = "italic";

  wrapper.appendChild(btn);
  wrapper.appendChild(note);
  // Insert the wrapper right after the lastSynced element (same placement as before)
  syncedEl.insertAdjacentElement("afterend", wrapper);

  // Show loading
  thead.innerHTML = "";
  tbody.innerHTML = `<tr><td colspan="5" style="text-align:center;">Loading...</td></tr>`;

  try {
    /* 1) Fetch tabs: Master, Bangalore, Mumbai, Amazon, All warehouses SKU */
    const [masterRes, blrRes, mumRes, amzRes, skuRes] = await Promise.all([
      fetchWarehouseData("Master"),
      fetchWarehouseData("Bangalore"),
      fetchWarehouseData("Mumbai"),
      fetchWarehouseData("Amazon"),
      fetchWarehouseData("All warehouses SKU")
    ]);

    /* 2) Parse Amazon for SKU list + synced date (same logic as old) */
    const amzHdrs = amzRes.headers.map(h => (h || "").toLowerCase().trim());
    const amzSkuIdx = amzHdrs.indexOf("sku");
    const amzAvailIdx = amzHdrs.indexOf("available");
    const amzDaysIdx = amzHdrs.indexOf("days to stockout");
    const amzSaleIdx = amzHdrs.indexOf("last 30 days sale");
    const amzSyncIdx = amzHdrs.indexOf("synced at");

    let lastSynced = "";
    if (amzSyncIdx !== -1 && amzRes.data.length > 0) {
      const raw = (amzRes.data[0][amzSyncIdx] || "").trim();
      if (raw.includes("/")) {
        const [dd, mm, yy] = raw.split("/");
        lastSynced = `${dd}-${mm}-${yy}`;
      } else if (raw.includes("-")) {
        const parts = raw.split("-");
        if (parts[0].length === 4) {
          const [yyyy, mm, dd] = raw.substring(0, 10).split("-");
          lastSynced = `${dd}-${mm}-${yyyy}`;
        } else {
          lastSynced = raw.substring(0, 10);
        }
      }
    }
    syncedEl.innerText = "LAST SYNCED: " + (lastSynced || "N/A");

    /* 3) Build lookup maps for each inventory tab */
    function buildMasterMap(res) {
      // Master sheet: labelled + non labelled only
      const hdrs = res.headers.map(h => (h || "").toLowerCase().trim());
      const skuI = hdrs.indexOf("sku");
      const labI = hdrs.indexOf("labelled");
      const nonLabI = hdrs.indexOf("non labelled");
      const map = new Map();
      res.data.forEach(row => {
        const sku = (row[skuI] || "").toString().trim();
        if (!sku) return;
        map.set(sku, {
          labelled: row[labI] || 0,
          nonlabelled: row[nonLabI] || 0
        });
      });
      return map;
    }

    function buildStandardMap(res) {
      const hdrs = res.headers.map(h => (h || "").toLowerCase().trim());
      const skuI = hdrs.indexOf("sku");
      const availI = hdrs.indexOf("available");
      const daysI = hdrs.indexOf("days to stockout");
      const saleI = hdrs.indexOf("last 30 days sale");
      const map = new Map();
      res.data.forEach(row => {
        const sku = (row[skuI] || "").toString().trim();
        if (!sku) return;
        map.set(sku, {
          available: row[availI] || "",
          days: row[daysI] || "",
          last30: row[saleI] || ""
        });
      });
      return map;
    }

    const masterMap = buildMasterMap(masterRes);
    const blrMap = buildStandardMap(blrRes);
    const mumMap = buildStandardMap(mumRes);
    const amzMap = buildStandardMap(amzRes);

    /* 4) Parse SKU override tab ("All warehouses SKU")
         Expected columns:
           A = display SKU (required)
           B = Master SKU (optional)
           C = Bangalore override (optional)
           D = Mumbai override (optional)
           E = Amazon override (optional)
       Rows with blank display column are ignored.
    */
    const skuValues = skuRes.data || [];
    const skuOverrideList = skuValues.map(row => ({
      display: row[0] ? row[0].toString().trim() : "",
      master: row[1] ? row[1].toString().trim() : "",
      blr: row[2] ? row[2].toString().trim() : "",
      mum: row[3] ? row[3].toString().trim() : "",
      amz: row[4] ? row[4].toString().trim() : ""
    })).filter(r => r.display !== "");

    /* If override list is empty, fallback to Amazon SKU list (preserve old behavior) */
    let finalSkuList = [];
    if (skuOverrideList.length > 0) {
      finalSkuList = skuOverrideList;
    } else {
      // create entries from Amazon map keys (display = amazon sku)
      finalSkuList = Array.from(amzMap.keys()).map(k => ({ display: k, master: "", blr: "", mum: "", amz: k }));
    }

    /* 5) Helper formatters */
    function formatMaster(masterObj) {
      if (!masterObj) return "-";
      const L = masterObj.labelled || 0;
      const NL = masterObj.nonlabelled || 0;
      if (!L && !NL) return "-";
      return `${L}(L)/${NL}(NL)`;
    }

    function formatStandard(obj) {
      if (!obj) return "-";
      const a = obj.available || "";
      const s = obj.last30 !== undefined ? obj.last30 : "";
      const d = obj.days !== undefined ? obj.days : "-";
      // show fallback if both available and days missing
      const hasAny = (a !== "" && a !== 0) || (d !== "-" && d !== "") || (s !== "" && s !== 0);
      if (!hasAny) return "-";
      if (s !== "" && s !== 0) return `${a || 0} [${s || 0}] (${d || "-"})`;
      return `${a || 0} (${d || "-"})`;
    }

    /* 6) Build rows using overrides */
    const rows = finalSkuList.map(entry => {
      const displaySKU = entry.display;

      const masterSKU = entry.master || displaySKU;
      const blrSKU = entry.blr || displaySKU;
      const mumSKU = entry.mum || displaySKU;
      const amzSKU = entry.amz || displaySKU;

      const masterObj = masterMap.get(masterSKU);
      const blrObj = blrMap.get(blrSKU);
      const mumObj = mumMap.get(mumSKU);
      const amzObj = amzMap.get(amzSKU);

      return {
        sku: displaySKU,
        masterStr: formatMaster(masterObj),
        blrStr: formatStandard(blrObj),
        mumStr: formatStandard(mumObj),
        amzStr: formatStandard(amzObj),
        blrDays: blrObj?.days || "",
        mumDays: mumObj?.days || "",
        amzDays: amzObj?.days || ""
      };
    });

    /* 7) Render table */
    thead.innerHTML = `
      <tr>
        <th>SKU</th>
        <th>Master</th>
        <th>SR-BLR</th>
        <th>SR-MUM</th>
        <th>Amazon</th>
      </tr>
    `;
    tbody.innerHTML = "";

    rows.forEach(r => {
      const blrColor = (!isNaN(parseFloat(r.blrDays)) && parseFloat(r.blrDays) < 10) ? "#FF4D4F" : "#333";
      const mumColor = (!isNaN(parseFloat(r.mumDays)) && parseFloat(r.mumDays) < 10) ? "#FF4D4F" : "#333";
      const amzColor = (!isNaN(parseFloat(r.amzDays)) && parseFloat(r.amzDays) < 20) ? "#FF4D4F" : "#333";

      const html = `
        <tr>
          <td>${r.sku}</td>
          <td>${r.masterStr}</td>
          <td style="color:${blrColor};font-weight:600;">${r.blrStr}</td>
          <td style="color:${mumColor};font-weight:600;">${r.mumStr}</td>
          <td style="color:${amzColor};font-weight:600;">${r.amzStr}</td>
        </tr>
      `;
      tbody.insertAdjacentHTML("beforeend", html);
    });

    if (rows.length === 0) {
      tbody.innerHTML = `<tr><td colspan="5" style="text-align:center;">No SKUs found.</td></tr>`;
    }
  } catch (err) {
    console.error("All Warehouses load error:", err);
    thead.innerHTML = "";
    tbody.innerHTML = `<tr><td colspan="5" style="color:red;text-align:center;">Error loading data. Check console.</td></tr>`;
    document.getElementById("lastSynced").innerText = "LAST SYNCED: N/A";
  }
}


  /* ===== EXPORT FUNCTION (with synced date) ===== */
function exportAllWarehouses() {
  const table = document.querySelector("#warehouse table");
  const syncedText = document.getElementById("lastSynced").innerText || "";
  let csv = "";

  // include last synced info at the top
  csv += `"${syncedText.replace(/"/g, '""')}"\n\n`;

  // now export the visible table
  const rows = table.querySelectorAll("tr");
  rows.forEach(row => {
    const cols = row.querySelectorAll("th,td");
    const arr = [];
    cols.forEach(c => arr.push(`"${c.innerText.replace(/"/g, '""')}"`));
    csv += arr.join(",") + "\n";
  });

  // download file
  const blob = new Blob([csv], { type: "text/csv" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  const syncDateMatch = syncedText.match(/\d{2}-\d{2}-\d{4}/);
  const syncDate = syncDateMatch ? syncDateMatch[0] : "unknown";
  a.href = url;
  a.download = `All_Warehouses_${syncDate}.csv`;
  a.click();
  URL.revokeObjectURL(url);
}

/* ====== BLINKIT ====== */

// Custom date parser for sheet values
function parseSheetDate(val){
  if(!val) return null;
  const s = String(val).trim();

  // yyyy-mm-dd or yyyy-mm-dd hh:mm:ss
  if(/^\d{4}-\d{2}-\d{2}/.test(s)){
    const [yyyy,mm,dd] = s.substring(0,10).split("-");
    return new Date(Number(yyyy), Number(mm)-1, Number(dd));
  }

  // dd-mm-yyyy
  if(/^\d{2}-\d{2}-\d{4}$/.test(s)){
    const [dd,mm,yyyy] = s.split("-");
    return new Date(Number(yyyy), Number(mm)-1, Number(dd));
  }

  // dd/mm/yyyy
  if(/^\d{2}\/\d{2}\/\d{4}$/.test(s)){
    const [dd,mm,yyyy] = s.split("/");
    return new Date(Number(yyyy), Number(mm)-1, Number(dd));
  }

  // fallback
  const d = new Date(s);
  return isNaN(d.getTime()) ? null : d;
}

// Parse input type=date (always yyyy-mm-dd)
function parseInputDate(val){
  if(!val) return null;
  const [yyyy,mm,dd] = val.split("-");
  return new Date(Number(yyyy), Number(mm)-1, Number(dd));
}

async function fetchBlinkitData(){
  const url = `https://sheets.googleapis.com/v4/spreadsheets/${BLINKIT_SHEET_ID}/values/${encodeURIComponent(BLINKIT_SHEET)}?key=${API_KEY}`;
  const res = await fetch(url);
  const json = await res.json();
  return json.values || [];
}

function groupBlinkitData(values,startDate,endDate){
  if(values.length < 2) return {cities:[], data:{}};
  const headers = values[0];
  const rows = values.slice(1);

  const dateIdx = headers.indexOf("Date");
  const productIdx = headers.indexOf("Product");
  const qtyIdx = headers.indexOf("Qty");
  const salesIdx = headers.indexOf("Sales");
  const cityIdx = headers.indexOf("City");

  const grouped = {}; 
  const cities = new Set();

  rows.forEach(r=>{
    const d = parseSheetDate(r[dateIdx]);
    if(!d) return;

    // inclusive filter
    if(startDate && d < startDate) return;
    if(endDate){
      const endDay = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate(), 23,59,59,999);
      if(d > endDay) return;
    }

    const product = r[productIdx] || "";
    const qty = parseFloat(r[qtyIdx]||0);
    const sales = parseFloat(r[salesIdx]||0);
    const city = r[cityIdx] || "Unknown";

    cities.add(city);
    if(!grouped[product]) grouped[product] = {qty:0,sales:0,byCity:{}};
    grouped[product].qty += qty;
    grouped[product].sales += sales;
    grouped[product].byCity[city] = (grouped[product].byCity[city]||0)+qty;
  });

  return {cities:[...cities], data:grouped};
}

async function loadBlinkitData(){
  const start = document.getElementById("startDate").value;
  const end = document.getElementById("endDate").value;
  const startDate = parseInputDate(start);
  const endDate = parseInputDate(end);

  const values = await fetchBlinkitData();
  const {cities,data} = groupBlinkitData(values,startDate,endDate);

  const table = document.getElementById("blinkitTable");
  const thead = table.querySelector("thead");
  const tbody = table.querySelector("tbody");
  const tfoot = table.querySelector("tfoot");

  let headerHTML="<tr><th>Product</th><th>Qty</th><th>Gross Sales</th>";
  cities.forEach(c=> headerHTML+=`<th>${c}</th>`);
  headerHTML+="</tr>";
  thead.innerHTML=headerHTML;

  let bodyHTML=""; let totalQty=0,totalSales=0; const cityTotals={};
  for(const [product,obj] of Object.entries(data)){
    totalQty+=obj.qty; totalSales+=obj.sales;
    let row=`<tr><td>${product}</td><td>${obj.qty}</td><td>${Math.round(obj.sales)}</td>`;
    cities.forEach(c=>{
      const val=obj.byCity[c]||0;
      row+=`<td>${val}</td>`;
      cityTotals[c]=(cityTotals[c]||0)+val;
    });
    row+="</tr>";
    bodyHTML+=row;
  }
  tbody.innerHTML=bodyHTML;

  let footHTML=`<tr><td><b>TOTAL</b></td><td><b>${totalQty}</b></td><td><b>${Math.round(totalSales)}</b></td>`;
  cities.forEach(c=> footHTML+=`<td><b>${cityTotals[c]||0}</b></td>`);
  footHTML+="</tr>";
  tfoot.innerHTML=footHTML;
}

function exportBlinkit(){
  const table=document.getElementById("blinkitTable");
  let csv=""; const rows=table.querySelectorAll("tr");
  rows.forEach(row=>{
    const cols=row.querySelectorAll("th,td");
    const arr=[]; cols.forEach(c=>arr.push(`"${c.innerText}"`));
    csv+=arr.join(",")+"\n";
  });
  const blob=new Blob([csv],{type:"text/csv"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a"); a.href=url; a.download="blinkit_sales.csv"; a.click();
  URL.revokeObjectURL(url);
}

// ====== Default date = Yesterday (auto-load) ======
document.addEventListener("DOMContentLoaded", ()=>{
  const today = new Date();
  const yesterday = new Date(today);
  yesterday.setDate(today.getDate() - 1);

  const yStr = yesterday.toISOString().slice(0,10);
  const sd = document.getElementById("startDate");
  const ed = document.getElementById("endDate");

  if(sd && ed){
    sd.value = yStr;
    ed.value = yStr;
    loadBlinkitData(); // auto-load yesterday's data
  }
});
/* ====== NAVIGATION ====== */
const SECTIONS = [
  "home",
  "inventory",
  "warehouse",
  "sales",
  "salesOverview",
  "salesShare",
  "blinkit",
  "amazonSales",
  "flipkartSales",
  "shopifySalesSection"
];

function showSection(id) {
  // üßπ Always remove All Warehouses controls when switching sections
  removeWarehouseControls();

  SECTIONS.forEach(s => document.getElementById(s).classList.add("hidden"));
  document.getElementById(id).classList.remove("hidden");
}
  
</script>

  <script>
/* ====== AMAZON (Orders + sheet1 combined) ====== */

const AMAZON_SHEET_ID = "1e4Vdkw2Ms0dCxskAKbUfLk3ttqeFT_nbQDhsPtKWWhA"; // Sales sheet
const AMAZON_RANGE = "sheet1"; // sales/refunds tab
const AMAZON_ORDERS_TAB = "Orders"; // orders tab name

// --- date helpers (kept compact & robust)
function fmtYMD(d){
  const m = String(d.getMonth()+1).padStart(2,"0");
  const day = String(d.getDate()).padStart(2,"0");
  return `${d.getFullYear()}-${m}-${day}`;
}
function parseSheetDate(val){
  if(!val) return null;
  const s = String(val).trim();
  // yyyy-mm-dd or yyyy-mm-dd hh:mm:ss
  if(/^\d{4}-\d{2}-\d{2}/.test(s)){
    const [yyyy,mm,dd] = s.substring(0,10).split("-");
    return new Date(Number(yyyy), Number(mm)-1, Number(dd));
  }
  // dd-mm-yyyy
  if(/^\d{2}-\d{2}-\d{4}$/.test(s)){
    const [dd,mm,yyyy] = s.split("-");
    return new Date(Number(yyyy), Number(mm)-1, Number(dd));
  }
  // dd/mm/yyyy
  if(/^\d{2}\/\d{2}\/\d{4}$/.test(s)){
    const [dd,mm,yyyy] = s.split("/");
    return new Date(Number(yyyy), Number(mm)-1, Number(dd));
  }
  // fallback
  const d = new Date(s);
  return isNaN(d.getTime()) ? null : d;
}

// local safe number parsers
function toIntSafe(n){ const x = Number(n); return isNaN(x)?0:Math.round(x); }
function toFloatSafe(n){ if(n===null||n===undefined) return 0; const s = String(n).replace(/,/g,"").trim(); const x = parseFloat(s); return isNaN(x)?0:x; }
function moneyInt(n){ return toIntSafe(n).toString(); }

// set default dates (yesterday) for Amazon inputs
function setAmazonDefaultDates(){
  const end = new Date(); end.setDate(end.getDate() - 1);
  const start = new Date(end);
  const sd = document.getElementById("amzStart");
  const ed = document.getElementById("amzEnd");
  if(sd) sd.value = fmtYMD(start);
  if(ed) ed.value = fmtYMD(end);
}

// fetch sheet1 (sales/refunds)
async function fetchAmazonValues(){
  const url = `https://sheets.googleapis.com/v4/spreadsheets/${AMAZON_SHEET_ID}/values/${encodeURIComponent(AMAZON_RANGE)}?key=${API_KEY}`;
  const res = await fetch(url);
  const json = await res.json();
  return json.values || [];
}

// fetch Orders tab (use explicit range to be safe)
async function fetchAmazonOrdersValues(){
  const range = `${encodeURIComponent(AMAZON_ORDERS_TAB)}!A1:Z`;
  const url = `https://sheets.googleapis.com/v4/spreadsheets/${AMAZON_SHEET_ID}/values/${range}?key=${API_KEY}`;
  const res = await fetch(url);
  const json = await res.json();
  return json.values || [];
}

// fetch days-to-stockout map from Warehouse Amazon tab (unchanged logic)
async function fetchAmazonStockData(){
  const url = `https://sheets.googleapis.com/v4/spreadsheets/${WAREHOUSE_SHEET_ID}/values/Amazon?key=${API_KEY}`;
  const res = await fetch(url);
  const json = await res.json();
  const values = json.values || [];
  if (values.length === 0) return new Map();

  const headers = values[0].map(h => (h || "").toString().trim().toLowerCase());
  const skuIndex = headers.indexOf("sku");
  const daysIndex = headers.indexOf("days to stockout");
  if (skuIndex === -1 || daysIndex === -1) return new Map();

  const stockMap = new Map();
  for (let i = 1; i < values.length; i++){
    const row = values[i];
    const sku = (row[skuIndex]||"").toString().trim();
    const days = (row[daysIndex]||"").toString().trim();
    if(sku) stockMap.set(sku, days);
  }
  return stockMap;
}

/*
  Aggregation rules implemented exactly:
  - Qty  = sum(quantity) from Orders tab per SKU (date filter on purchase-date)
  - Gross = sum(item-price) from Orders tab per SKU (sum of prices, not qty*price)
  - RTO & Refunds = from sheet1 where Type == 'refund' (date filter on Date)
  - Discount (Buy2) = sum(item-promotion-discount) from Orders rows matching promotion-id substring
*/
function aggregateOrdersAndSheet1(ordersVals, sheetVals, orderStart, orderEnd, sheetStart, sheetEnd){
  // ordersVals and sheetVals are arrays from Google Sheets API (headers+rows)
  const skuMap = new Map();

  // --- Process Orders tab (purchase-date)
  if((ordersVals || []).length >= 1){
    const headers = ordersVals[0].map(h => (h||"").toString().trim().toLowerCase());
    const idxDate = headers.indexOf("purchase-date");
    const idxSku = headers.indexOf("sku");
    const idxQty = headers.indexOf("quantity");
    const idxPrice = headers.indexOf("item-price");
    const idxPromoDisc = headers.indexOf("item-promotion-discount");
    const idxPromoId = headers.indexOf("promotion-ids");

    for(let i=1;i<ordersVals.length;i++){
      const row = ordersVals[i];
      const d = (idxDate!==-1) ? parseSheetDate(row[idxDate]) : null;
      if(!d) continue;
      // inclusive filter
      if(orderStart && d < orderStart) continue;
      if(orderEnd){
        const endDay = new Date(orderEnd.getFullYear(), orderEnd.getMonth(), orderEnd.getDate(), 23,59,59,999);
        if(d > endDay) continue;
      }

      const sku = (idxSku!==-1 ? (row[idxSku]||"") : "").toString().trim();
      if(!sku) continue;

      const qty = toIntSafe(idxQty!==-1 ? row[idxQty] : 0);
      const price = toFloatSafe(idxPrice!==-1 ? row[idxPrice] : 0);
      const promoDisc = toFloatSafe(idxPromoDisc!==-1 ? row[idxPromoDisc] : 0);
      const promoId = idxPromoId!==-1 ? (row[idxPromoId]||"").toString() : "";

      if(!skuMap.has(sku)){
        skuMap.set(sku, { sku, qty:0, gross:0, rto:0, refunds:0, promoQty:0, promoDiscountSum:0 });
      }
      const rec = skuMap.get(sku);
      rec.qty += qty;
      rec.gross += price; // as requested: gross is sum of item-price
      // track Buy2 promo rows (exact substring match)
      // If this Orders row belongs to the "Buy 2 Get 15% OFF" promo id,
// calculate discount as 15% of item-price (since item-price is already total)
      if (typeof promoId === "string" && promoId.indexOf("Percentage Off 2025/08/27 7-27-42-779") !== -1) {
        rec.promoQty += qty;
        rec.promoDiscountSum += (price * 0.15);
        console.log("Promo match:", sku, "Item price:", price, "‚Üí Discount added:", price * 0.15);
      }
    }
  }

  // --- Process sheet1 for refunds (Date, Type = refund)
  if((sheetVals || []).length >= 1){
    const headers = sheetVals[0].map(h => (h||"").toString().trim().toLowerCase());
    const idxDate = headers.indexOf("date");
    const idxType = headers.indexOf("type");
    const idxSku = headers.indexOf("sku");
    const idxQty = headers.indexOf("qty");
    const idxSales = headers.indexOf("sales(-gst)");

    for(let i=1;i<sheetVals.length;i++){
      const row = sheetVals[i];
      const d = (idxDate!==-1) ? parseSheetDate(row[idxDate]) : null;
      if(!d) continue;
      // inclusive filter on sheet1 Date
      if(sheetStart && d < sheetStart) continue;
      if(sheetEnd){
        const endDay = new Date(sheetEnd.getFullYear(), sheetEnd.getMonth(), sheetEnd.getDate(), 23,59,59,999);
        if(d > endDay) continue;
      }

      const type = idxType!==-1 ? (row[idxType]||"").toString().trim().toLowerCase() : "";
      if(type !== "refund") continue;

      const sku = idxSku!==-1 ? (row[idxSku]||"").toString().trim() : "";
      if(!sku) continue;

      const qty = toIntSafe(idxQty!==-1 ? row[idxQty] : 0);
      const salesVal = toFloatSafe(idxSales!==-1 ? row[idxSales] : 0);

      if(!skuMap.has(sku)){
        skuMap.set(sku, { sku, qty:0, gross:0, rto:0, refunds:0, promoQty:0, promoDiscountSum:0 });
      }
      const rec = skuMap.get(sku);
      rec.rto += qty;
      rec.refunds += Math.abs(salesVal);
    }
  }

  // Convert to array
  const rows = Array.from(skuMap.values());
  // Sort by gross desc
  rows.sort((a,b) => b.gross - a.gross);
  return rows;
}

// --- Evaluate STEP Premium with new rules (updated 15% discount logic + 0.95x gross)
function evaluateStepNew(totals, startDate, endDate){
  const targetSalesPerDay = 55000;
  const targetQtyPerDay = 110;

  const s = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
  const e = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
  const days = Math.floor((e - s)/(1000*60*60*24)) + 1;

  const salesTarget = targetSalesPerDay * days;
  const qtyTarget = targetQtyPerDay * days;

  // apply new step logic
  const netForStep = (0.95 * totals.gross) - totals.refunds - totals.discount;
  const qtyEligible = totals.qty - totals.rto;

  const fulfilled = (netForStep >= salesTarget) || (qtyEligible >= qtyTarget);

  return { fulfilled, days, netForStep, qtyEligible, salesTarget, qtyTarget };
}


// --- Render combined Amazon table (SKU | Qty | Gross | RTO | Refunds | Days to Stockout)
function renderAmazonCombined(rows, stockMap){
  const tbl = document.getElementById("amazonTable");
  const thead = tbl.querySelector("thead");
  const tbody = tbl.querySelector("tbody");
  const tfoot = tbl.querySelector("tfoot");

  thead.innerHTML = `
    <tr>
      <th>Sku</th>
      <th>Qty</th>
      <th>Gross</th>
      <th>RTO</th>
      <th>Refunds</th>
      <th>Days to Stockout</th>
    </tr>
  `;

  let bodyHTML = "";
  let totalQty = 0, totalGross = 0, totalRto = 0, totalRefunds = 0;

  rows.forEach(r=>{
    const days = stockMap.get(r.sku) || "‚Äî";
    const color = (typeof days === "string") ? "#333" : (parseFloat(days) < 20 ? "#FF4D4F" : "#333");

    bodyHTML += `
      <tr>
        <td>${r.sku}</td>
        <td>${r.qty}</td>
        <td>${moneyInt(r.gross)}</td>
        <td>${r.rto || 0}</td>
        <td>${moneyInt(r.refunds)}</td>
        <td style="color:${color}; font-weight:600;">${days}</td>
      </tr>
    `;
    totalQty += r.qty;
    totalGross += r.gross;
    totalRto += r.rto;
    totalRefunds += r.refunds;
  });

  tbody.innerHTML = bodyHTML || `<tr><td colspan="6">No data in this date range.</td></tr>`;

  tfoot.innerHTML = `
    <tr>
      <td><b>TOTAL</b></td>
      <td><b>${totalQty}</b></td>
      <td><b>${moneyInt(totalGross)}</b></td>
      <td><b>${totalRto}</b></td>
      <td><b>${moneyInt(totalRefunds)}</b></td>
      <td></td>
    </tr>
  `;

  return { qty: totalQty, gross: totalGross, rto: totalRto, refunds: totalRefunds };
}

// --- Render STEP badge and promo line (clean UI)
function renderStepAndPromo(totals, startDate, endDate, promoSummary){
  const badge = document.getElementById("amzStepBadge");
  const evalRes = evaluateStepNew({ qty: totals.qty, gross: totals.gross, rto: totals.rto, refunds: totals.refunds, discount: promoSummary.discount }, startDate, endDate);
  if(evalRes.fulfilled){
    badge.textContent = evalRes.days === 1 ? "STEP Premium Target ‚Äì Fulfilled (For applied date)" : "STEP Premium Target ‚Äì Fulfilled (For applied date range)";
    badge.style.background = "#0f915a";
  } else {
    badge.textContent = evalRes.days === 1 ? "STEP Premium Target ‚Äì Unfulfilled (For applied date)" : "STEP Premium Target ‚Äì Unfulfilled (For applied date range)";
    badge.style.background = "#ff4d4f";
  }
  badge.style.color = "white";

  // promo line
  let promoLine = document.getElementById("amzPromoLine");
  if(!promoLine){
    promoLine = document.createElement("div");
    promoLine.id = "amzPromoLine";
    promoLine.style.fontWeight = "700";
    promoLine.style.marginTop = "6px";
    promoLine.style.textAlign = "center";
    const wrap = document.getElementById("amzStepWrap");
    if(wrap) wrap.appendChild(promoLine);
  }
  promoLine.innerHTML = `
  <span style="background:#000000;color:white;padding:8px 12px;border-radius:999px;
  font-weight:700;text-transform:uppercase;display:inline-block;text-align:center;">
    BUY 2 GET 15% OFF ‚Äî Rs.${moneyInt(promoSummary.discount || 0)} (${promoSummary.qty || 0} units)
  </span>
`;

promoLine.style.marginTop = "4px";
promoLine.style.textAlign = "center";

  return evalRes;
}

// --- Export CSV for Amazon table (same format as displayed)
function exportAmazonCSV(){
  const table = document.getElementById("amazonTable");
  let csv = "";
  table.querySelectorAll("tr").forEach(tr=>{
    const cols = tr.querySelectorAll("th,td");
    const line = Array.from(cols).map(td => `"${td.innerText.replace(/"/g,'""')}"`).join(",");
    csv += line + "\n";
  });
  const blob = new Blob([csv], {type:"text/csv"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = "amazon_sales.csv"; a.click();
  URL.revokeObjectURL(url);
}

// --- Main loader: fetch Orders + sheet1 + stock, aggregate, render
async function loadAmazonSales(){
  try{
    const startVal = document.getElementById("amzStart").value;
    const endVal   = document.getElementById("amzEnd").value;
    if(!startVal || !endVal){ alert("Please select a date range."); return; }

    const orderStart = new Date(new Date(startVal).setHours(0,0,0,0));
    const orderEnd   = new Date(new Date(endVal).setHours(23,59,59,999));
    // sheet1 uses Date column - use same date inputs but keep separate variables in case formats differ
    const sheetStart = orderStart;
    const sheetEnd = orderEnd;

    // fetch in parallel
    const [ordersVals, sheetVals, stockMap] = await Promise.all([
      fetchAmazonOrdersValues(),
      fetchAmazonValues(),
      fetchAmazonStockData()
    ]);

    // aggregate
    const rows = aggregateOrdersAndSheet1(ordersVals, sheetVals, orderStart, orderEnd, sheetStart, sheetEnd);

  
  // promo summary (Buy2 - actual 15% of item-price per promotion item)
let promoSummary = { qty: 0, discount: 0 };
rows.forEach(r => {
  promoSummary.qty += (r.promoQty || 0);
  promoSummary.discount += (r.promoDiscountSum || 0); // use computed value directly
});


    // render table
    const totals = renderAmazonCombined(rows, stockMap);

    // render STEP badge + promo line
    renderStepAndPromo(totals, orderStart, orderEnd, promoSummary);

  }catch(err){
    console.error(err);
    alert("Could not load Amazon data. Check console for details.");
  }
}

// --- initialize UI: set defaults, wire buttons, auto-load yesterday
(function initAmazonUI(){
  const applyBtn = document.getElementById("amzApply");
  const exportBtn = document.getElementById("amzExport");
  if(!applyBtn) return;

  setAmazonDefaultDates();
  applyBtn.addEventListener("click", loadAmazonSales);
  exportBtn.addEventListener("click", exportAmazonCSV);

  // auto-load yesterday on initial page entry
  loadAmazonSales();
})();


/* ====== FLIPKART SALES OVERVIEW (Google Sheets Integration) ====== */

const FLIPKART_SHEET_ID = "1e98eoyoGOeEiQ3hFAKBON-VH85byuXV042vzqC8Yhkw";
const FK_SALES_TAB = "SALES";
const FK_RTO_TAB = "RTO";
const FK_WAREHOUSE_TAB = "Bangalore"; // from Warehouse sheet (Days to Stockout)

/* ---- Helpers ---- */
function parseFlipkartDate(val) {
  if (!val) return null;
  const s = String(val).trim();
  if (/^\d{2}\/\d{2}\/\d{4}$/.test(s)) {
    const [dd, mm, yyyy] = s.split("/");
    return new Date(+yyyy, +mm - 1, +dd);
  }
  if (/^\d{4}-\d{2}-\d{2}/.test(s)) {
    const [y, m, d] = s.substring(0, 10).split("-");
    return new Date(+y, +m - 1, +d);
  }
  const d = new Date(s);
  return isNaN(d.getTime()) ? null : d;
}

function toNum(n) {
  const x = parseFloat(String(n || "").replace(/,/g, ""));
  return isNaN(x) ? 0 : x;
}

/* ---- Fetch any tab (use explicit range to avoid 400) ---- */
async function fetchFlipkartTab(tabName) {
  const range = `${encodeURIComponent(tabName)}!A1:Z`;
  const url = `https://sheets.googleapis.com/v4/spreadsheets/${FLIPKART_SHEET_ID}/values/${range}?key=${API_KEY}`;
  const res = await fetch(url);
  const json = await res.json();
  return json.values || [];
}

/* ---- Fetch warehouse data ---- */
async function fetchBangaloreStock() {
  const range = `${encodeURIComponent(FK_WAREHOUSE_TAB)}!A1:Z`;
  const url = `https://sheets.googleapis.com/v4/spreadsheets/${WAREHOUSE_SHEET_ID}/values/${range}?key=${API_KEY}`;
  const res = await fetch(url);
  const json = await res.json();
  const values = json.values || [];
  const map = new Map();
  if (values.length > 1) {
    const headers = values[0].map(h => (h || "").trim().toLowerCase());
    const skuIdx = headers.indexOf("sku");
    const daysIdx = headers.indexOf("days to stockout");
    if (skuIdx === -1 || daysIdx === -1) {
      // header mismatch: return empty map
      return map;
    }
    for (let i = 1; i < values.length; i++) {
      const row = values[i];
      const sku = (row[skuIdx] || "").trim();
      const days = (row[daysIdx] || "").trim();
      if (sku) map.set(sku, days);
    }
  }
  return map;
}

/* ---- Combine Sales + RTO + Warehouse ---- */
function combineFlipkartData(salesVals, rtoVals, stockMap, startDate, endDate) {
  if ((salesVals || []).length < 2 && (rtoVals || []).length < 2) return [];

  // Identify headers (safely)
  const sHead = (salesVals[0] || []).map(h => (h || "").toString().trim().toLowerCase());
  const rHead = (rtoVals[0] || []).map(h => (h || "").toString().trim().toLowerCase());

  const sDateIdx = sHead.indexOf("ordered on");
  const sSkuIdx = sHead.indexOf("sku");
  const sQtyIdx = sHead.indexOf("quantity");
  const sAmtIdx = sHead.indexOf("invoice amount");

  const rDateIdx = rHead.indexOf("order cancellation date");
  const rSkuIdx = rHead.indexOf("sku");
  const rQtyIdx = rHead.indexOf("quantity");
  const rAmtIdx = rHead.indexOf("total");

  const byKey = new Map();

  // inclusive end-of-day for filtering
  const endInclusive = endDate ? new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate(), 23, 59, 59, 999) : null;

  // --- SALES aggregation ---
if (salesVals && salesVals.length > 1 && sDateIdx !== -1 && sSkuIdx !== -1) {
  for (let i = 1; i < salesVals.length; i++) {
    const row = salesVals[i];
    const d = parseFlipkartDate(row[sDateIdx]);
    if (!d) continue;
    if (startDate && d < startDate) continue;
    if (endInclusive && d > endInclusive) continue;

    const sku = (row[sSkuIdx] || "").trim();
    if (!sku) continue;

    // group by SKU only (combine across dates)
    const key = sku;
    if (!byKey.has(key)) byKey.set(key, { sku, qty: 0, gross: 0, rto: 0, refund: 0 });
    const rec = byKey.get(key);
    rec.qty += toNum(row[sQtyIdx]);
    rec.gross += toNum(row[sAmtIdx]);
  }
}

// --- RTO aggregation ---
if (rtoVals && rtoVals.length > 1 && rDateIdx !== -1 && rSkuIdx !== -1) {
  for (let i = 1; i < rtoVals.length; i++) {
    const row = rtoVals[i];
    const d = parseFlipkartDate(row[rDateIdx]);
    if (!d) continue;
    if (startDate && d < startDate) continue;
    if (endInclusive && d > endInclusive) continue;

    const sku = (row[rSkuIdx] || "").trim();
    if (!sku) continue;

    // group by SKU only (combine across dates)
    const key = sku;
    if (!byKey.has(key)) byKey.set(key, { sku, qty: 0, gross: 0, rto: 0, refund: 0 });
    const rec = byKey.get(key);
    rec.rto += toNum(row[rQtyIdx]);
    rec.refund += toNum(row[rAmtIdx]);
  }
}

  // --- Merge Days to Stockout ---
  const rows = [];
  byKey.forEach(rec => {
    rec.days = stockMap.get(rec.sku) || "‚Äî";
    rows.push(rec);
  });

  // --- Sort by highest Qty descending
  rows.sort((a, b) => b.qty - a.qty);

  return rows;
}

/* ---- Render Table ---- */
function renderFlipkartTable(rows) {
  const tbl = document.getElementById("flipkartTable");
  const thead = tbl.querySelector("thead");
  const tbody = tbl.querySelector("tbody");
  const tfoot = tbl.querySelector("tfoot");

  thead.innerHTML = `
    <tr>
      <th>SKU</th>
      <th>Qty</th>
      <th>Gross</th>
      <th>RTO</th>
      <th>Refunds</th>
      <th>Days to Stockout</th>
    </tr>
  `;

  let totalQty = 0, totalGross = 0, totalRto = 0, totalRefund = 0;
  let bodyHTML = "";

  if (!rows || rows.length === 0) {
    tbody.innerHTML = `<tr><td colspan="6">No data found for this range.</td></tr>`;
    tfoot.innerHTML = `
      <tr>
        <td><b>TOTAL</b></td>
        <td><b>0</b></td>
        <td><b>0</b></td>
        <td><b>0</b></td>
        <td><b>0</b></td>
        <td></td>
      </tr>
    `;
    return;
  }

  rows.forEach(r => {
    totalQty += r.qty;
    totalGross += r.gross;
    totalRto += r.rto;
    totalRefund += r.refund;

    const days = parseFloat(r.days);
    const color = !isNaN(days) && days < 10 ? "#FF4D4F" : "#333";

    bodyHTML += `
      <tr>
        <td>${r.sku}</td>
        <td>${r.qty}</td>
        <td>${r.gross.toFixed(0)}</td>
        <td>${r.rto}</td>
        <td>${r.refund.toFixed(0)}</td>
        <td style="color:${color}; font-weight:600;">${r.days}</td>
      </tr>
    `;
  });

  tbody.innerHTML = bodyHTML;
  tfoot.innerHTML = `
    <tr>
      <td><b>TOTAL</b></td>
      <td><b>${totalQty}</b></td>
      <td><b>${totalGross.toFixed(0)}</b></td>
      <td><b>${totalRto}</b></td>
      <td><b>${totalRefund.toFixed(0)}</b></td>
      <td></td>
    </tr>
  `;
}

/* ---- Export CSV ---- */
function exportFlipkartCSV() {
  const table = document.getElementById("flipkartTable");
  let csv = "";
  table.querySelectorAll("tr").forEach(tr => {
    const cols = tr.querySelectorAll("th,td");
    const line = Array.from(cols).map(td => `"${td.innerText.replace(/"/g, '""')}"`).join(",");
    csv += line + "\n";
  });
  const blob = new Blob([csv], { type: "text/csv" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = "flipkart_sales.csv"; a.click();
  URL.revokeObjectURL(url);
}

/* ---- Load Flipkart Sales ---- */
async function loadFlipkartSales() {
  try {
    const startVal = document.getElementById("fkStart").value;
    const endVal = document.getElementById("fkEnd").value;
    if (!startVal || !endVal) return alert("Please select a date range.");
    const startDate = new Date(startVal);
startDate.setHours(0, 0, 0, 0); // start from beginning of the selected day

const endDate = new Date(endVal);
endDate.setHours(23, 59, 59, 999); // include the entire end day


    const [salesVals, rtoVals, stockMap] = await Promise.all([
      fetchFlipkartTab(FK_SALES_TAB),
      fetchFlipkartTab(FK_RTO_TAB),
      fetchBangaloreStock()
    ]);

    const rows = combineFlipkartData(salesVals, rtoVals, stockMap, startDate, endDate);
    renderFlipkartTable(rows);
  } catch (err) {
    console.error("Flipkart load error:", err);
    alert("Error loading Flipkart data. See console for details.");
  }
}

/* ---- Init UI ---- */
(function initFlipkartUI() {
  const applyBtn = document.getElementById("fkApply");
  const exportBtn = document.getElementById("fkExport");
  if (!applyBtn) return;

  // Default date: yesterday
  const today = new Date();
  const y = new Date(today);
  y.setDate(today.getDate() - 1);
  const yStr = y.toISOString().slice(0, 10);
  document.getElementById("fkStart").value = yStr;
  document.getElementById("fkEnd").value = yStr;

    applyBtn.addEventListener("click", loadFlipkartSales);
  exportBtn.addEventListener("click", exportFlipkartCSV);

  // ‚úÖ Auto-load yesterday's data on page load
  loadFlipkartSales();
})();
    
</script>


  
  

  <script>
/* ====== ADVANCED SHOPIFY DASHBOARD ====== */
const SHOPIFY_API_KEY = "AIzaSyD6yREIVE1b8hq0kiYqFoJBfsLzPiGGv4k";
const SHOPIFY_SHEET_ID = "1JlCAQoJkF8sLm3RvQ_fGmALmLOR4bo338pZB2gQIhJk";
const TAB_ORDERS = "Orders_API";
const TAB_SHEET1 = "Sheet1";

/* --- Helpers --- */
function parseShopifyDate(val) {
  if (!val && val !== 0) return null;
  const s = String(val).trim();
  if (!s) return null;
  // dd-mm-yyyy or dd/mm/yyyy
  let m = s.match(/^(\d{1,2})[\/-](\d{1,2})[\/-](\d{4})$/);
  if (m) {
    const dd = Number(m[1]), mm = Number(m[2]), yyyy = Number(m[3]);
    return new Date(yyyy, mm - 1, dd);
  }
  // yyyy-mm-dd
  m = s.match(/^(\d{4})-(\d{1,2})-(\d{1,2})/);
  if (m) {
    const yyyy = Number(m[1]), mm = Number(m[2]), dd = Number(m[3]);
    return new Date(yyyy, mm - 1, dd);
  }
  const d = new Date(s);
  return isNaN(d.getTime()) ? null : d;
}

function toNum(v){
  if (v === null || v === undefined || v === '') return 0;
  const s = String(v).replace(/,/g, '').trim();
  const n = parseFloat(s);
  return isNaN(n) ? 0 : n;
}

// Correct Indian comma format (no decimals)
function fmtINR(x) {
  x = Math.round(Number(x) || 0);
  const sign = x < 0 ? '-' : '';
  x = Math.abs(x);
  let s = String(x);
  if (s.length <= 3) return sign + s;
  const last3 = s.slice(-3);
  const other = s.slice(0, -3);
  const formatted = other.replace(/\B(?=(\d{2})+(?!\d))/g, ",") + "," + last3;
  return sign + formatted;
}

function startOfDay(d){ const x=new Date(d); x.setHours(0,0,0,0); return x; }
function endOfDay(d){ const x=new Date(d); x.setHours(23,59,59,999); return x; }

/* fetch one tab from the Shopify spreadsheet (expects SHOPIFY_API_KEY & SHOPIFY_SHEET_ID globals) */
async function fetchTab(tab){
  if (typeof SHOPIFY_API_KEY === 'undefined' || typeof SHOPIFY_SHEET_ID === 'undefined') {
    throw new Error('SHOPIFY_API_KEY or SHOPIFY_SHEET_ID not defined globally.');
  }
  const range = encodeURIComponent(tab) + '!A1:Z';
  const url = `https://sheets.googleapis.com/v4/spreadsheets/${SHOPIFY_SHEET_ID}/values/${range}?key=${SHOPIFY_API_KEY}`;
  const res = await fetch(url);
  if (!res.ok) {
    const txt = await res.text().catch(()=>'<no body>');
    throw new Error('Fetch failed for ' + tab + ': ' + res.status + ' ' + res.statusText + ' ' + txt);
  }
  const j = await res.json();
  return j.values || [];
}

/* --- Main loader & renderer --- */
async function loadShopifyDashboard(){
  try {
    const sVal = document.getElementById('shopifyStart').value;
    const eVal = document.getElementById('shopifyEnd').value;
    if (!sVal || !eVal) return alert('Select start and end dates.');

    const s = startOfDay(new Date(sVal));
    const e = endOfDay(new Date(eVal));

    const tBody = document.querySelector('#shopifyTable tbody');
    tBody.innerHTML = '<tr><td colspan="4" style="text-align:center;padding:24px;">Fetching Shopify data...</td></tr>';

    // fetch both tabs in parallel
    const [ordersVals, sheet1Vals] = await Promise.all([
      fetchTab(TAB_ORDERS),
      fetchTab(TAB_SHEET1)
    ]);

    if (!ordersVals.length || !sheet1Vals.length) {
      tBody.innerHTML = '<tr><td colspan="4" style="text-align:center;padding:24px;">No data or invalid sheet access.</td></tr>';
      return;
    }

    // headers (normalized)
    const hdrO = ordersVals[0].map(h => (h||'').toString().toLowerCase().trim());
    const hdrS = sheet1Vals[0].map(h => (h||'').toString().toLowerCase().trim());

    const oIdx = {
      sku: hdrO.indexOf('sku'),
      qty: hdrO.indexOf('qty'),
      price: hdrO.indexOf('price (per unit)'),
      date: hdrO.indexOf('date'),
      order: hdrO.indexOf('order number'),
      discApp: hdrO.indexOf('discount application'),
      ship: hdrO.indexOf('shipping charges'),
      disc: hdrO.indexOf('discounts')
    };

    const sIdx = {
      sku: hdrS.indexOf('master sku'),
      qty: hdrS.indexOf('product quantity'),
      rto: hdrS.indexOf('rto initiated date'),
      del: hdrS.indexOf('order delivered date'),
      order: hdrS.indexOf('order id'),
      total: hdrS.indexOf('order total')
    };

    // aggregator containers
    const skuMap = new Map();         // sku -> {sku, qty, gross}
    const rtoUnits = new Map();       // masterSku -> units

    const orderNumsSet = new Set();   // unique order numbers from Orders_API
    const shippingMap = new Map();    // orderNumber -> shipping (first)
    const discountMap = new Map();    // orderNumber -> discount (first)

    const rtoOrderSet = new Set();    // unique order ids in RTO (Sheet1)
    const refundOrderMap = new Map(); // orderId -> orderTotal (first)
    const deliveredSet = new Set();   // unique delivered order ids

    let pack2 = 0, pack3 = 0;

    // Process Orders_API rows (by Date column)
    for (let i = 1; i < ordersVals.length; i++) {
      const row = ordersVals[i];
      const dateVal = row[oIdx.date];
      const parsed = parseShopifyDate(dateVal);
      if (!parsed || parsed < s || parsed > e) continue;

      const sku = (row[oIdx.sku] || '').toString().trim();
      const qty = toNum(row[oIdx.qty]);
      const price = toNum(row[oIdx.price]);
      const orderNum = (row[oIdx.order] || '').toString().trim();
      const discApp = (row[oIdx.discApp] || '').toString().trim();
      const ship = toNum(row[oIdx.ship]);
      const disc = toNum(row[oIdx.disc]);

      if (!sku) continue;

      // aggregate per-SKU (gross = per-row qty * per-row price then summed)
      if (!skuMap.has(sku)) skuMap.set(sku, { sku, qty: 0, gross: 0 });
      const rec = skuMap.get(sku);
      rec.qty += qty;
      rec.gross += qty * price;

      // pack counts (per-row)
      if (discApp === 'Pack of 2') pack2++;
      if (discApp === 'Pack of 3') pack3++;

      // track shipping/discount once per unique order number
      if (orderNum) {
        if (!shippingMap.has(orderNum)) shippingMap.set(orderNum, ship);
        if (!discountMap.has(orderNum)) discountMap.set(orderNum, disc);
        orderNumsSet.add(orderNum);
      }
    }

    // Process Sheet1 rows for RTO / Refunds / Delivered
    for (let i = 1; i < sheet1Vals.length; i++) {
      const row = sheet1Vals[i];
      const rtoDateVal = row[sIdx.rto];
      const delDateVal = row[sIdx.del];
      const rtoDate = parseShopifyDate(rtoDateVal);
      const delDate = parseShopifyDate(delDateVal);
      const masterSku = (row[sIdx.sku] || '').toString().trim();
      const prodQty = toNum(row[sIdx.qty]);
      const orderId = (row[sIdx.order] || '').toString().trim();
      const orderTotal = toNum(row[sIdx.total]);

      // RTO initiated date range
      if (rtoDate && rtoDate >= s && rtoDate <= e) {
        if (masterSku) rtoUnits.set(masterSku, (rtoUnits.get(masterSku) || 0) + prodQty);
        if (orderId) {
          rtoOrderSet.add(orderId);
          if (!refundOrderMap.has(orderId) && orderTotal) refundOrderMap.set(orderId, orderTotal);
        }
      }

      // Delivered date range
      if (delDate && delDate >= s && delDate <= e && orderId) {
        deliveredSet.add(orderId);
      }
    }

    // Build left table rows (union of SKUs from Orders_API and Master SKUs from Sheet1 RTO)
    const allKeys = [...new Set([...skuMap.keys(), ...rtoUnits.keys()])];
    let totalQty = 0, totalGross = 0, totalRto = 0;
    let rowsHTML = '';

    allKeys.forEach(k => {
      const qty = skuMap.get(k)?.qty || 0;
      const gross = skuMap.get(k)?.gross || 0;
      const rto = rtoUnits.get(k) || 0;
      rowsHTML += `<tr>
        <td style="text-align:center;">${k}</td>
        <td style="text-align:center;">${fmtINR(qty)}</td>
        <td style="text-align:center;">${fmtINR(gross)}</td>
        <td style="text-align:center;">${fmtINR(rto)}</td>
      </tr>`;
      totalQty += qty;
      totalGross += gross;
      totalRto += rto;
    });

    tBody.innerHTML = rowsHTML || '<tr><td colspan="4" style="text-align:center;padding:24px;">No data.</td></tr>';
    document.querySelector('#shopifyTable tfoot').innerHTML = `<tr>
      <td><b>TOTAL</b></td>
      <td style="text-align:center;"><b>${fmtINR(totalQty)}</b></td>
      <td style="text-align:center;"><b>${fmtINR(totalGross)}</b></td>
      <td style="text-align:center;"><b>${fmtINR(totalRto)}</b></td>
    </tr>`;

    // compute unique-order totals properly
    const shippingSum = Array.from(shippingMap.values()).reduce((a,b)=>a+b,0);
    const discountSum = Array.from(discountMap.values()).reduce((a,b)=>a+b,0);
    const refundSum = Array.from(refundOrderMap.values()).reduce((a,b)=>a+b,0);

    const totalOrders = orderNumsSet.size;
    const rtoCount = rtoOrderSet.size;
    const deliveredCount = deliveredSet.size;
    const totalSales = totalGross + shippingSum - discountSum;
    const netSales = totalSales - refundSum;

    // render summary table (with info icons)
    const summaryRows = [
      ['Total Orders', totalOrders],
      ['RTO', rtoCount],
      ['DELIVERED', deliveredCount],
      ['Pack of 2', pack2],
      ['Pack of 3', pack3],
      ['Shipping Charges', shippingSum],
      ['Discounts', discountSum],
      ['Refunds', refundSum],
      [`Total Sales <span class="info-icon" title="Gross + Shipping Charges - Discounts">‚ÑπÔ∏è</span>`, totalSales],
      [`Net Sales <span class="info-icon" title="Total Sales - Refunds">‚ÑπÔ∏è</span>`, netSales]
    ];

    document.querySelector('#shopifySummary tbody').innerHTML = summaryRows.map(([k,v])=>
      `<tr><td style="padding:10px 14px;">${k}</td><td style="text-align:right;padding:10px 14px;">${fmtINR(v)}</td></tr>`
    ).join('');

  } catch (err) {
    console.error('Shopify dashboard error:', err);
    const tBody = document.querySelector('#shopifyTable tbody');
    if (tBody) tBody.innerHTML = `<tr><td colspan="4" style="text-align:center;padding:24px;color:#d00;">Error fetching data. Check console.</td></tr>`;
  }
}

/* --- Export CSV for SKU table --- */
function exportShopifyCSV(){
  const t = document.querySelector('#shopifyTable');
  if (!t) return;
  let csv = '';
  t.querySelectorAll('tr').forEach(tr=>{
    const cols = tr.querySelectorAll('th,td');
    const arr = Array.from(cols).map(td => `"${td.innerText.replace(/"/g,'""')}"`);
    csv += arr.join(',') + '\n';
  });
  const blob = new Blob([csv], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'shopify_sales.csv'; a.click(); URL.revokeObjectURL(url);
}

/* --- Wiring: Apply & Export buttons --- */
(function wireShopifyButtons(){
  const applyBtn = document.getElementById('shopifyApply');
  if (applyBtn) {
    applyBtn.removeEventListener?.('click', loadShopifyDashboard);
    applyBtn.addEventListener('click', loadShopifyDashboard);
  }
  const exportBtn = document.getElementById('shopifyExport');
  if (exportBtn) {
    exportBtn.removeEventListener?.('click', exportShopifyCSV);
    exportBtn.addEventListener('click', exportShopifyCSV);
  }
})();

(function injectShopifyStyles(){
  const style = document.createElement('style');
  style.textContent = `
    /* ===== GENERAL TABLE ALIGNMENT ===== */
    #shopifySalesSection thead th {
      text-align: center;
      vertical-align: middle;
      padding: 14px;
      font-weight: 700;
    }
    #shopifySalesSection tbody td {
      text-align: center;
      vertical-align: middle;
      padding: 12px 14px;
      border-bottom: 1px solid #f0f0f0;
    }

    /* ===== BLUE TABLE HEADER ===== */
    #shopifyTable {
      border-collapse: collapse;
      border-spacing: 0;
      width: 100%;
      margin-top: 0;
    }
    #shopifyTable thead th {
      background: #1C39BB !important;
      color: #fff;
      border: none;
      padding: 14px;
    }
    #shopifyTable thead tr:first-child th:first-child {
      border-top-left-radius: 12px;
    }
    #shopifyTable thead tr:first-child th:last-child {
      border-top-right-radius: 12px;
    }
    #shopifyTable thead {
      background-clip: padding-box;
    }

    /* ===== SUMMARY TABLE HEADER (BLACK) ===== */
    #shopifySummary {
      border-collapse: collapse;
      border-spacing: 0;
      width: 100%;
      margin-top: 0;
    }
    #shopifySummary thead th {
      background: #000 !important;
      color: #fff !important;
      text-align: center;
      font-weight: 700;
      text-transform: uppercase;
      padding: 14px;
      border: none;
    }
    #shopifySummary thead tr:first-child th:first-child {
      border-top-left-radius: 12px;
    }
    #shopifySummary thead tr:first-child th:last-child {
      border-top-right-radius: 12px;
    }
    #shopifySummary thead {
      background-clip: padding-box;
    }

    /* ===== INFO ICON TOOLTIP FIX ===== */
    .info-icon {
      position: relative;
      font-size: 12px;
      margin-left: 6px;
      cursor: help;
      color: #1C39BB;
      display: inline-block;
      vertical-align: middle;
    }
    .info-icon:hover::after {
      content: attr(title);
      position: absolute;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.9);
      color: #fff;
      padding: 6px 8px;
      border-radius: 6px;
      font-size: 12px;
      line-height: 1.4;
      white-space: nowrap;
      z-index: 10000;
      box-shadow: 0 2px 8px rgba(0,0,0,0.25);
      pointer-events: none;
    }
    #shopifySummary td {
      position: relative;
      overflow: visible;
    }

    /* ===== FILTER BAR SPACING & ALIGNMENT ===== */
    #shopifySalesSection .filters {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 12px;
      margin-top: 20px;
      margin-bottom: 24px;
      flex-wrap: wrap;
    }
    #shopifySalesSection input[type="date"],
    #shopifySalesSection .btn {
      height: 38px;
      line-height: 38px;
      padding: 0 14px;
      font-size: 15px;
      border-radius: 6px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
    }
    #shopifySalesSection input[type="date"] {
      border: 1px solid #ccc;
      background: #fff;
    }
    #shopifySalesSection .btn {
      font-weight: 600;
      letter-spacing: 0.5px;
      border: none;
    }

    /* === FINAL FIX: Shopify button alignment override === */
#shopifySalesSection .btn {
  margin-top: 0 !important;      /* removes global 30px offset */
  transform: none !important;    /* clears the var(--btn-nudge) shift */
  position: relative !important;
  top: 0 !important;
  line-height: 40px !important;
  height: 40px !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  vertical-align: middle !important;
}

/* just to ensure both buttons share same baseline */
#shopifyApply,
#shopifyExport {
  margin-top: 0 !important;
  margin-bottom: 0 !important;
  top: 0 !important;
}

#shopifySalesSection button.btn[onclick*="showSection('salesOverview')"] {
  margin-top: 40px !important;   /* increase space below the tables */
}



    /* ===== TABLES CONTAINER SPACING ===== */
    #shopifySalesSection .tables-container {
      margin-top: 10px;
      align-items: flex-start;
      gap: 20px;
    }

    /* ===== REMOVE TOP GAP BETWEEN TABLE AND CONTAINER ===== */
    #shopifySalesSection > div > table,
    #shopifySalesSection > div {
      margin-top: 0 !important;
      padding-top: 0 !important;
    }

    /* ===== RESPONSIVE ===== */
    @media (max-width: 900px) {
      .tables-container {
        grid-template-columns: 1fr;
      }
    }
  `;
  document.head.appendChild(style);
})();

/* Auto-load yesterday (safe) */
(function(){
  try {
    const y = new Date(); y.setDate(y.getDate() - 1);
    const yStr = y.toISOString().slice(0,10);
    const sEl = document.getElementById('shopifyStart');
    const eEl = document.getElementById('shopifyEnd');
    if (sEl) sEl.value = yStr;
    if (eEl) eEl.value = yStr;
    // tiny delay to let DOM settle
    setTimeout(()=>{ if (typeof loadShopifyDashboard === 'function') loadShopifyDashboard(); }, 120);
  } catch (e) {
    console.warn('Shopify auto-load error', e);
  }
})();

</script>

 
<script>
  
  <!-- PWA Installer + Service Worker -->
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker
      .register('./service-worker.js')
      .then(reg => {
        console.log('‚úÖ Service Worker registered:', reg.scope);

        // Auto-update if new version detected
        if (reg.waiting) reg.waiting.postMessage({ type: 'SKIP_WAITING' });
        reg.addEventListener('updatefound', () => {
          const newWorker = reg.installing;
          newWorker?.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              console.log('‚ö° New version available. Reloading...');
              newWorker.postMessage({ type: 'SKIP_WAITING' });
              window.location.reload();
            }
          });
        });
      })
      .catch(err => console.error('‚ùå SW registration failed:', err));
  });
}

// --- Install prompt for Android ---
let deferredPrompt;
window.addEventListener('beforeinstallprompt', e => {
  e.preventDefault();
  deferredPrompt = e;

  const installBtn = document.createElement('button');
  installBtn.textContent = 'üì≤ Install Byte Wellness App';
  installBtn.className = 'btn';
  Object.assign(installBtn.style, {
    position: 'fixed',
    bottom: '25px',
    left: '50%',
    transform: 'translateX(-50%)',
    zIndex: '9999',
    background: '#1C39BB',
    color: '#fff',
    border: 'none',
    padding: '12px 20px',
    borderRadius: '10px',
    fontWeight: '700',
    textTransform: 'uppercase',
    boxShadow: '0 4px 10px rgba(0,0,0,0.2)'
  });

  document.body.appendChild(installBtn);
  installBtn.addEventListener('click', async () => {
    installBtn.style.display = 'none';
    deferredPrompt.prompt();
    const choice = await deferredPrompt.userChoice;
    console.log('User install choice:', choice.outcome);
    deferredPrompt = null;
  });
});

window.addEventListener('appinstalled', () => {
  console.log('‚úÖ Byte Wellness App installed!');
});
</script>

  <script>
// Enforce true 1:1 zoom on mobile (prevents Chrome's auto-fit)
document.addEventListener("DOMContentLoaded", function() {
  document.querySelector('meta[name="viewport"]').setAttribute(
    "content",
    "width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
  );
});
</script>

  <script>
/* ====== SMART PWA BACK BUTTON FIX ====== */
document.addEventListener("DOMContentLoaded", function () {
  const sectionStack = [];
  const allSections = document.querySelectorAll(".container");

  // Keep reference to your original showSection (if any)
  const originalShowSection = window.showSection || function(id) {
    allSections.forEach(sec => sec.classList.add("hidden"));
    const target = document.getElementById(id);
    if (target) target.classList.remove("hidden");
  };

  // Wrap showSection with history handling
  window.showSection = function (id) {
    const current = sectionStack[sectionStack.length - 1];
    if (current !== id) {
      sectionStack.push(id);
      history.pushState({ section: id }, "", `#${id}`);
    }

    // Show only the chosen section
    allSections.forEach(sec => sec.classList.add("hidden"));
    const target = document.getElementById(id);
    if (target) target.classList.remove("hidden");
  };

  // Handle browser/OS back button
  window.addEventListener("popstate", function (event) {
    if (sectionStack.length > 1) {
      sectionStack.pop();
      const prev = sectionStack[sectionStack.length - 1];
      allSections.forEach(sec => sec.classList.add("hidden"));
      const target = document.getElementById(prev);
      if (target) target.classList.remove("hidden");
    } else {
      // Already at home ‚Üí confirm before closing
      if (confirm("Exit the app?")) {
        window.close();
      } else {
        history.pushState({}, "", "#mainMenu"); // prevent accidental close
      }
    }
  });

  // Initialize stack with the visible section (usually main menu)
  const visible = Array.from(allSections).find(sec => !sec.classList.contains("hidden"));
  sectionStack.push(visible ? visible.id : "mainMenu");
  history.replaceState({ section: visible ? visible.id : "mainMenu" }, "", `#${visible ? visible.id : "mainMenu"}`);
});
</script>


  
 <!-- ü•ß TOTAL SALES & SHARE SECTION -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>

<script>
const chartColors = {
  Amazon: '#FF9900',
  Flipkart: '#2874F0',
  Shopify: '#96BF48',
  Blinkit: '#F7E415'
};

async function fetchSalesData(channel, start, end) {
  const sheets = {
    Amazon: {
      id: '1e4Vdkw2Ms0dCxskAKbUfLk3ttqeFT_nbQDhsPtKWWhA',
      tab: 'Orders',
      dateCol: 'purchase-date'
    },
    Flipkart: {
      id: '1e98eoyoGOeEiQ3hFAKBON-VH85byuXV042vzqC8Yhkw',
      tab: 'SALES',
      dateCol: 'ordered on'
    },
    Shopify: {
      id: '1JlCAQoJkF8sLm3RvQ_fGmALmLOR4bo338pZB2gQIhJk',
      tab: 'Orders_API',
      dateCol: 'date'
    },
    Blinkit: {
      id: '1LJ7H8Zwy8-mM_1K0TCdke-89qfK00yQAV04OtitC45Q',
      tab: 'sheet1',
      dateCol: 'date'
    }
  }[channel];

  try {
    const url = `https://sheets.googleapis.com/v4/spreadsheets/${sheets.id}/values/${encodeURIComponent(sheets.tab)}!A1:Z?key=${API_KEY}`;
    const res = await fetch(url);
    const data = await res.json();
    const vals = data.values || [];
    if (vals.length < 2) return 0;

    const headers = vals[0].map(h => (h || "").toLowerCase().trim());
    const dateIdx = headers.indexOf(sheets.dateCol);
    if (dateIdx === -1) return 0;

    let gross = 0;

    for (let i = 1; i < vals.length; i++) {
      const d = parseDate(vals[i][dateIdx]);
      if (!d || d < start || d > end) continue;

      // ---- Parse values per channel ----
      if (channel === 'Amazon') {
        const priceIdx = headers.indexOf('item-price');
        const discountIdx = headers.indexOf('item-promotion-discount');
        const price = parseFloat((vals[i][priceIdx] || '0').replace(/,/g, '')) || 0;
        const discount = parseFloat((vals[i][discountIdx] || '0').replace(/,/g, '')) || 0;
        gross += (price - discount);
      } else if (channel === 'Flipkart') {
        const idx = headers.indexOf('invoice amount');
        const val = parseFloat((vals[i][idx] || '0').replace(/,/g, '')) || 0;
        gross += val;
      } else if (channel === 'Shopify') {
  const orderIdx = headers.indexOf('order number');
  const totalIdx = headers.indexOf('total price (order)');
  const orderNo = (vals[i][orderIdx] || "").trim();

  // ‚úÖ Use a Set to ensure each order is counted only once
  if (!window._countedShopifyOrders) window._countedShopifyOrders = new Set();

  if (!window._countedShopifyOrders.has(orderNo)) {
    const val = parseFloat((vals[i][totalIdx] || '0').replace(/,/g, '')) || 0;
    gross += val;
    window._countedShopifyOrders.add(orderNo);
  }

      } else if (channel === 'Blinkit') {
        const idx = headers.indexOf('sales');
        const val = parseFloat((vals[i][idx] || '0').replace(/,/g, '')) || 0;
        gross += val;
      }
    }
    return gross;
  } catch (err) {
    console.warn(`Error fetching ${channel}:`, err);
    return 0;
  }
}

// üóìÔ∏è Parse different date formats
function parseDate(v) {
  if (!v) return null;
  const s = String(v).trim();
  if (/^\d{4}-\d{2}-\d{2}/.test(s)) return new Date(s);
  if (/^\d{2}[\/-]\d{2}[\/-]\d{4}$/.test(s)) {
    const [d, m, y] = s.split(/[\/-]/);
    return new Date(`${y}-${m}-${d}`);
  }
  const d = new Date(s);
  return isNaN(d) ? null : d;
}

let salesChart;

async function renderSalesShare() {
  const sVal = document.getElementById("shareStart").value;
  const eVal = document.getElementById("shareEnd").value;
  if (!sVal || !eVal) return alert("Select both From and To dates");

  window._countedShopifyOrders = new Set();

  const start = new Date(sVal);
  start.setHours(0, 0, 0, 0);
  const end = new Date(eVal);
  end.setHours(23, 59, 59, 999);

  document.getElementById("salesShareStatus").innerText = "Fetching data...";

  const [amazon, flipkart, shopify, blinkit] = await Promise.all([
    fetchSalesData("Amazon", start, end),
    fetchSalesData("Flipkart", start, end),
    fetchSalesData("Shopify", start, end),
    fetchSalesData("Blinkit", start, end)
  ]);

  const totals = { Amazon: amazon, Flipkart: flipkart, Shopify: shopify, Blinkit: blinkit };
  const totalSum = Object.values(totals).reduce((a, b) => a + b, 0);

  if (totalSum === 0) {
    document.getElementById("salesShareStatus").innerText = "No sales data for this date range.";
    return;
  }

// üîπ Legend with Rounded Gross Values + Total Sales
let legendHTML = Object.entries(totals).map(([k, v]) => {
  const color = chartColors[k];
  const roundedVal = Math.round(v);
  return `
    <div style="margin-bottom:8px;">
      <span style="
        display:inline-block;
        width:16px;
        height:16px;
        background:${color};
        border-radius:3px;
        margin-right:8px;">
      </span>
      ${k} ‚Äî ‚Çπ${roundedVal.toLocaleString('en-IN')}
    </div>
  `;
}).join("");

// üßÆ Add Total Sales line
const totalRounded = Math.round(totalSum).toLocaleString('en-IN');
legendHTML += `
  <hr style="border:0;border-top:1px solid #ccc;margin:8px 0;">
  <div style="font-weight:700; color:#1C39BB; font-size:17px;">
    Total Sales ‚Äî ‚Çπ${totalRounded}
  </div>
`;

// ‚úÖ Inject into the page
document.getElementById("salesShareLegend").innerHTML = legendHTML;


  const ctx = document.getElementById("salesShareChart").getContext("2d");
  if (salesChart) salesChart.destroy();

  // üîπ Chart size control
  salesChart = new Chart(ctx, {
    type: 'pie',
    data: {
      labels: Object.keys(totals),
      datasets: [{
        data: Object.values(totals),
        backgroundColor: Object.keys(totals).map(k => chartColors[k]),
        borderWidth: 2
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: true, // üëà important
      layout: { padding: 10 },
      plugins: {
        legend: { display: false },
        datalabels: {
          color: '#FFFFFF',
          font: { weight: 'bold', size: 13 },
          formatter: (v, ctx) => Math.round((v / totalSum) * 100) + '%'
        },
        title: {
          display: true,
          text: 'Sales Share by Channel',
          font: { size: 18, weight: 'bold' }
        }
      }
    },
    plugins: [ChartDataLabels]
  });

  document.getElementById("salesShareStatus").innerText = "";
}

// üóìÔ∏è Default = Yesterday, but don‚Äôt render chart
document.addEventListener("DOMContentLoaded", () => {
  const today = new Date();
  const yesterday = new Date(today);
  yesterday.setDate(today.getDate() - 1);

  const yStr = yesterday.toISOString().split("T")[0];
  document.getElementById("shareStart").value = yStr;
  document.getElementById("shareEnd").value = yStr;

  // ‚ùå no auto render ‚Äî chart only appears after user clicks Apply
});
</script>





</body>
</html>























